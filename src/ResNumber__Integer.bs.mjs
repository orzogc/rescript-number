// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_int from "rescript/lib/es6/js_int.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as ResNumber__Math from "./ResNumber__Math.bs.mjs";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as ResNumber__Utils from "./ResNumber__Utils.bs.mjs";
import * as ResNumber__Operation from "./ResNumber__Operation.bs.mjs";

function toInt32(i) {
  return i | 0;
}

function toUint32(i) {
  return (i >>> 0);
}

function MakeIntegerConversion(IntRange) {
  var minValue = IntRange.minValue;
  var maxValue = IntRange.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Number.MIN_SAFE_INTEGER || maxValue > Number.MAX_SAFE_INTEGER) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Number.MIN_SAFE_INTEGER.toString() + " - " + Number.MAX_SAFE_INTEGER.toString());
  }
  var fromInt = function (i) {
    if (i >= minValue && i <= maxValue) {
      return i;
    }
    
  };
  var fromIntExn = function (i) {
    if (i >= minValue && i <= maxValue) {
      return i;
    } else {
      return ResNumber__Utils.raiseOverflow(i, IntRange);
    }
  };
  var fromIntClamped = function (i) {
    if (i < minValue) {
      return minValue;
    } else if (i > maxValue) {
      return maxValue;
    } else {
      return i;
    }
  };
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    }
    
  };
  var toIntExn = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    } else {
      return ResNumber__Utils.raiseOverflow(i, ResNumber__Utils.Int32Range);
    }
  };
  var toIntClamped = function (i) {
    if (i < Js_int.min) {
      return Js_int.min;
    } else if (i > Js_int.max) {
      return Js_int.max;
    } else {
      return i;
    }
  };
  var toIntUnsafe = function (i) {
    return i | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return Math.trunc(f);
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return Math.trunc(f);
    }
  };
  var toFloat = function (f) {
    return f;
  };
  var fromString = function (s) {
    var f = ResNumber__Utils.stringToFloat(s);
    if (f !== undefined) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = ResNumber__Utils.stringToFloat(s);
    if (f !== undefined) {
      return fromFloatExn(f);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString
        };
}

function MakeInteger(IntRange) {
  var minValue = IntRange.minValue;
  var maxValue = IntRange.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Number.MIN_SAFE_INTEGER || maxValue > Number.MAX_SAFE_INTEGER) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Number.MIN_SAFE_INTEGER.toString() + " - " + Number.MAX_SAFE_INTEGER.toString());
  }
  var fromInt = function (i) {
    if (i >= minValue && i <= maxValue) {
      return i;
    }
    
  };
  var fromIntExn = function (i) {
    if (i >= minValue && i <= maxValue) {
      return i;
    } else {
      return ResNumber__Utils.raiseOverflow(i, IntRange);
    }
  };
  var fromIntClamped = function (i) {
    if (i < minValue) {
      return minValue;
    } else if (i > maxValue) {
      return maxValue;
    } else {
      return i;
    }
  };
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    }
    
  };
  var toIntExn = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    } else {
      return ResNumber__Utils.raiseOverflow(i, ResNumber__Utils.Int32Range);
    }
  };
  var toIntClamped = function (i) {
    if (i < Js_int.min) {
      return Js_int.min;
    } else if (i > Js_int.max) {
      return Js_int.max;
    } else {
      return i;
    }
  };
  var toIntUnsafe = function (i) {
    return i | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return Math.trunc(f);
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return Math.trunc(f);
    }
  };
  var toFloat = function (f) {
    return f;
  };
  var fromString = function (s) {
    var f = ResNumber__Utils.stringToFloat(s);
    if (f !== undefined) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = ResNumber__Utils.stringToFloat(s);
    if (f !== undefined) {
      return fromFloatExn(f);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  var minValue$1 = IntRange.minValue;
  var maxValue$1 = IntRange.maxValue;
  if (minValue$1 > 0.0 || maxValue$1 < 1.0) {
    PervasivesU.invalid_arg((0.0).toString() + " and " + (1.0).toString() + " must be between minValue " + minValue$1.toString() + " and maxValue " + maxValue$1.toString());
  }
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]);
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]);
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue$1) {
      return minValue$1;
    } else if (f > maxValue$1) {
      return maxValue$1;
    } else {
      return f;
    }
  };
  var addUnsafe = function (a, b) {
    return a + b;
  };
  var add = function (a, b) {
    return fromFloatUncheckInteger(a + b);
  };
  var addExn = function (a, b) {
    return fromFloatUncheckIntegerExn(a + b);
  };
  var addClamped = function (a, b) {
    return fromFloatUncheckIntegerClamped(a + b);
  };
  var subUnsafe = function (a, b) {
    return a - b;
  };
  var sub = function (a, b) {
    return fromFloatUncheckInteger(a - b);
  };
  var subExn = function (a, b) {
    return fromFloatUncheckIntegerExn(a - b);
  };
  var subClamped = function (a, b) {
    return fromFloatUncheckIntegerClamped(a - b);
  };
  var mulUnsafe = function (a, b) {
    return a * b;
  };
  var mul = function (a, b) {
    return fromFloatUncheckInteger(a * b);
  };
  var mulExn = function (a, b) {
    return fromFloatUncheckIntegerExn(a * b);
  };
  var mulClamped = function (a, b) {
    return fromFloatUncheckIntegerClamped(a * b);
  };
  var divUnsafe = function (a, b) {
    return Math.trunc(a / b);
  };
  var div = function (a, b) {
    if (b !== 0.0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = function (a, b) {
    if (b !== 0.0) {
      return divUnsafe(a, b);
    }
    throw {
          RE_EXN_ID: "Division_by_zero",
          Error: new Error()
        };
  };
  var remUnsafe = function (a, b) {
    return a % b;
  };
  var rem = function (a, b) {
    if (b !== 0.0) {
      return a % b;
    }
    
  };
  var remExn = function (a, b) {
    if (b !== 0.0) {
      return a % b;
    }
    throw {
          RE_EXN_ID: "Division_by_zero",
          Error: new Error()
        };
  };
  var include = ResNumber__Operation.MakeNumberIncDec({
        one: 1.0,
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe,
        sub: sub,
        subExn: subExn,
        subClamped: subClamped,
        subUnsafe: subUnsafe
      });
  var include$1 = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          zero: 0.0,
          one: 1.0,
          minValue: minValue$1,
          maxValue: maxValue$1,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          inc: include.inc,
          incExn: include.incExn,
          incUnsafe: include.incUnsafe,
          dec: include.dec,
          decExn: include.decExn,
          decUnsafe: include.decUnsafe,
          sum: include$1.sum,
          sumExn: include$1.sumExn,
          sumUnsafe: include$1.sumUnsafe
        };
}

function MakeFixedBitsIntegerConversion(IntRange) {
  var minValue = IntRange.minValue;
  var maxValue = IntRange.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromInt = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i;
        }
      });
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromInt(i);
    }
    
  };
  var fromStringExn = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromIntExn(i);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString
        };
}

function MakeFixedBitsInt(IntRange) {
  var minValue = IntRange.minValue;
  var maxValue = IntRange.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromInt = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i;
        }
      });
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromInt(i);
    }
    
  };
  var fromStringExn = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromIntExn(i);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  var minValue$1 = IntRange.minValue;
  var maxValue$1 = IntRange.maxValue;
  if (minValue$1 > 0 || maxValue$1 < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue$1.toString() + " and maxValue " + maxValue$1.toString());
  }
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]);
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]);
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue$1) {
      return minValue$1;
    } else if (f > maxValue$1) {
      return maxValue$1;
    } else {
      return f;
    }
  };
  var isAddMaybeOverflow = minValue$1 + minValue$1 < Js_int.min || maxValue$1 + maxValue$1 > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue$1 - maxValue$1 < Js_int.min || maxValue$1 - minValue$1 > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue$1 * maxValue$1 < Js_int.min || minValue$1 * minValue$1 > Js_int.max || maxValue$1 * maxValue$1 > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = Caml_int32.mod_;
  var include = ResNumber__Operation.MakeNumberIncDec({
        one: 1,
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe,
        sub: sub,
        subExn: subExn,
        subClamped: subClamped,
        subUnsafe: subUnsafe
      });
  var include$1 = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          zero: 0,
          one: 1,
          minValue: minValue$1,
          maxValue: maxValue$1,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          inc: include.inc,
          incExn: include.incExn,
          incUnsafe: include.incUnsafe,
          dec: include.dec,
          decExn: include.decExn,
          decUnsafe: include.decUnsafe,
          sum: include$1.sum,
          sumExn: include$1.sumExn,
          sumUnsafe: include$1.sumUnsafe
        };
}

function MakeFixedBitsInteger(M) {
  var IntRange_minValue = M.minValue;
  var IntRange_maxValue = M.maxValue;
  var IntRange = {
    minValue: IntRange_minValue,
    maxValue: IntRange_maxValue
  };
  var minValue = M.minValue;
  var maxValue = M.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromInt = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i;
        }
      });
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromInt(i);
    }
    
  };
  var fromStringExn = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromIntExn(i);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  var minValue$1 = M.minValue;
  var maxValue$1 = M.maxValue;
  if (minValue$1 > 0 || maxValue$1 < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue$1.toString() + " and maxValue " + maxValue$1.toString());
  }
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]);
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]);
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue$1) {
      return minValue$1;
    } else if (f > maxValue$1) {
      return maxValue$1;
    } else {
      return f;
    }
  };
  var isAddMaybeOverflow = minValue$1 + minValue$1 < Js_int.min || maxValue$1 + maxValue$1 > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue$1 - maxValue$1 < Js_int.min || maxValue$1 - minValue$1 > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue$1 * maxValue$1 < Js_int.min || minValue$1 * minValue$1 > Js_int.max || maxValue$1 * maxValue$1 > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = Caml_int32.mod_;
  var include = ResNumber__Operation.MakeNumberIncDec({
        one: 1,
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe,
        sub: sub,
        subExn: subExn,
        subClamped: subClamped,
        subUnsafe: subUnsafe
      });
  var include$1 = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  var bits = M.bits;
  if (bits <= 0 || bits > 32) {
    PervasivesU.invalid_arg("bits must not be less than 1 or greater than 32: " + bits.toString());
  }
  var isSigned = M.isSigned;
  var isUnsigned = !isSigned;
  if (isSigned) {
    var n = toUint32(minValue$1);
    if (Math.log2(n) !== (bits - 1 | 0)) {
      PervasivesU.invalid_arg("invalid minValue " + minValue$1.toString() + " for " + bits.toString() + " bits signed integer");
    }
    if (n - 1.0 !== maxValue$1) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue$1.toString() + " for " + bits.toString() + " bits signed integer");
    }
    
  }
  if (isUnsigned) {
    if (minValue$1 !== 0) {
      PervasivesU.invalid_arg("invalid minValue " + minValue$1.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    if (Math.pow(2.0, bits) - 1.0 !== maxValue$1) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue$1.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    
  }
  var is32Bits = bits === 32;
  var mask = Math.pow(2.0, bits) - 1.0 | 0;
  var maskNot = PervasivesU.lnot(mask);
  var highestBit = (1 << (bits - 1 | 0));
  var lnot = isUnsigned ? (function (i) {
        return PervasivesU.lnot(i) & mask;
      }) : PervasivesU.lnot;
  var land = function (prim0, prim1) {
    return prim0 & prim1;
  };
  var lor = function (prim0, prim1) {
    return prim0 | prim1;
  };
  var lxor = function (prim0, prim1) {
    return prim0 ^ prim1;
  };
  var modBits = function (n) {
    if (n < 0 || n >= bits) {
      return toUint32(n) % bits;
    } else {
      return n;
    }
  };
  var lsl = is32Bits ? (function (prim0, prim1) {
        return (prim0 << prim1);
      }) : (
      isSigned ? (function (i, n) {
            var v = (i << modBits(n));
            if ((v & highestBit) === 0) {
              return v & mask;
            } else {
              return v | maskNot;
            }
          }) : (function (i, n) {
            return (i << modBits(n)) & mask;
          })
    );
  var lsr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >>> prim1) | 0;
      }) : (
      isSigned ? (function (i, n) {
            return ((i & mask) >>> modBits(n)) | 0;
          }) : (function (i, n) {
            return (i >>> modBits(n)) | 0;
          })
    );
  var asr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >> prim1);
      }) : (function (i, n) {
        return (i >> modBits(n));
      });
  var rlsl = function (i, n) {
    var m = modBits(n);
    return lsl(i, m) | lsr(i, bits - m | 0);
  };
  var rlsr = function (i, n) {
    var m = modBits(n);
    return lsr(i, m) | lsl(i, bits - m | 0);
  };
  var clz = is32Bits ? (function (i) {
        return Math.clz32(i);
      }) : (function (i) {
        var c = Math.clz32(i);
        if (c > 0) {
          return c - (32 - bits | 0) | 0;
        } else {
          return c;
        }
      });
  var imul = is32Bits ? (function (a, b) {
        return Math.imul(a, b);
      }) : (
      isSigned ? (function (a, b) {
            var i = Math.imul(a, b);
            if ((i & highestBit) === 0) {
              return i & mask;
            } else {
              return i | maskNot;
            }
          }) : (function (a, b) {
            return Math.imul(a, b) & mask;
          })
    );
  var include$2 = ResNumber__Math.MakeIntegerMath({
        fromFloat: fromFloat,
        fromFloatExn: fromFloatExn,
        fromFloatClamped: fromFloatClamped,
        fromFloatUnsafe: fromFloatUnsafe,
        toFloat: toFloat,
        clz: clz,
        imul: imul
      });
  return {
          isSigned: isSigned,
          isUnsigned: isUnsigned,
          bits: bits,
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          zero: 0,
          one: 1,
          minValue: minValue$1,
          maxValue: maxValue$1,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          inc: include.inc,
          incExn: include.incExn,
          incUnsafe: include.incUnsafe,
          dec: include.dec,
          decExn: include.decExn,
          decUnsafe: include.decUnsafe,
          sum: include$1.sum,
          sumExn: include$1.sumExn,
          sumUnsafe: include$1.sumUnsafe,
          lnot: lnot,
          land: land,
          lor: lor,
          lxor: lxor,
          lsl: lsl,
          lsr: lsr,
          asr: asr,
          rlsl: rlsl,
          rlsr: rlsr,
          clz: include$2.clz,
          imul: include$2.imul,
          pow: include$2.pow,
          powExn: include$2.powExn,
          powUnsafe: include$2.powUnsafe,
          random: include$2.random
        };
}

function MakeSignedInteger(M) {
  var bits = M.bits;
  var minValue = M.minValue;
  var maxValue = M.maxValue;
  var IntRange = {
    minValue: minValue,
    maxValue: maxValue
  };
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromInt = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i;
        }
      });
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromInt(i);
    }
    
  };
  var fromStringExn = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromIntExn(i);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  if (minValue > 0 || maxValue < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue.toString() + " and maxValue " + maxValue.toString());
  }
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]);
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]);
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f;
    }
  };
  var isAddMaybeOverflow = minValue + minValue < Js_int.min || maxValue + maxValue > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue - maxValue < Js_int.min || maxValue - minValue > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue * maxValue < Js_int.min || minValue * minValue > Js_int.max || maxValue * maxValue > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = Caml_int32.mod_;
  var include = ResNumber__Operation.MakeNumberIncDec({
        one: 1,
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe,
        sub: sub,
        subExn: subExn,
        subClamped: subClamped,
        subUnsafe: subUnsafe
      });
  var include$1 = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  if (bits <= 0 || bits > 32) {
    PervasivesU.invalid_arg("bits must not be less than 1 or greater than 32: " + bits.toString());
  }
  var isUnsigned = false;
  var n = toUint32(minValue);
  if (Math.log2(n) !== (bits - 1 | 0)) {
    PervasivesU.invalid_arg("invalid minValue " + minValue.toString() + " for " + bits.toString() + " bits signed integer");
  }
  if (n - 1.0 !== maxValue) {
    PervasivesU.invalid_arg("invalid maxValue " + maxValue.toString() + " for " + bits.toString() + " bits signed integer");
  }
  if (isUnsigned) {
    if (minValue !== 0) {
      PervasivesU.invalid_arg("invalid minValue " + minValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    if (Math.pow(2.0, bits) - 1.0 !== maxValue) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    
  }
  var is32Bits = bits === 32;
  var mask = Math.pow(2.0, bits) - 1.0 | 0;
  var maskNot = PervasivesU.lnot(mask);
  var highestBit = (1 << (bits - 1 | 0));
  var lnot = isUnsigned ? (function (i) {
        return PervasivesU.lnot(i) & mask;
      }) : PervasivesU.lnot;
  var land = function (prim0, prim1) {
    return prim0 & prim1;
  };
  var lor = function (prim0, prim1) {
    return prim0 | prim1;
  };
  var lxor = function (prim0, prim1) {
    return prim0 ^ prim1;
  };
  var modBits = function (n) {
    if (n < 0 || n >= bits) {
      return toUint32(n) % bits;
    } else {
      return n;
    }
  };
  var lsl = is32Bits ? (function (prim0, prim1) {
        return (prim0 << prim1);
      }) : (function (i, n) {
        var v = (i << modBits(n));
        if ((v & highestBit) === 0) {
          return v & mask;
        } else {
          return v | maskNot;
        }
      });
  var lsr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >>> prim1) | 0;
      }) : (function (i, n) {
        return ((i & mask) >>> modBits(n)) | 0;
      });
  var asr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >> prim1);
      }) : (function (i, n) {
        return (i >> modBits(n));
      });
  var rlsl = function (i, n) {
    var m = modBits(n);
    return lsl(i, m) | lsr(i, bits - m | 0);
  };
  var rlsr = function (i, n) {
    var m = modBits(n);
    return lsr(i, m) | lsl(i, bits - m | 0);
  };
  var clz = is32Bits ? (function (i) {
        return Math.clz32(i);
      }) : (function (i) {
        var c = Math.clz32(i);
        if (c > 0) {
          return c - (32 - bits | 0) | 0;
        } else {
          return c;
        }
      });
  var imul = is32Bits ? (function (a, b) {
        return Math.imul(a, b);
      }) : (function (a, b) {
        var i = Math.imul(a, b);
        if ((i & highestBit) === 0) {
          return i & mask;
        } else {
          return i | maskNot;
        }
      });
  var include$2 = ResNumber__Math.MakeIntegerMath({
        fromFloat: fromFloat,
        fromFloatExn: fromFloatExn,
        fromFloatClamped: fromFloatClamped,
        fromFloatUnsafe: fromFloatUnsafe,
        toFloat: toFloat,
        clz: clz,
        imul: imul
      });
  var neg = function (i) {
    if (i !== minValue) {
      return -i | 0;
    }
    
  };
  var negExn = function (i) {
    var v = neg(i);
    if (v !== undefined) {
      return v;
    } else {
      return ResNumber__Utils.raiseOverflow(- i, {
                  minValue: M.minValue,
                  maxValue: M.maxValue
                });
    }
  };
  var negUnsafe = function (i) {
    return -i | 0;
  };
  var abs = function (i) {
    if (i !== minValue) {
      return Math.abs(i);
    }
    
  };
  var absExn = function (i) {
    var v = abs(i);
    if (v !== undefined) {
      return v;
    } else {
      return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                  minValue: M.minValue,
                  maxValue: M.maxValue
                });
    }
  };
  var absUnsafe = function (i) {
    return PervasivesU.abs(i);
  };
  var signExn = function (i) {
    var match = Math.sign(i);
    switch (match) {
      case -1 :
          return -1;
      case 0 :
          return 0;
      case 1 :
          return 1;
      default:
        return 0;
    }
  };
  var sign = function (i) {
    return signExn(i);
  };
  var signRaw = function (i) {
    return Math.sign(i);
  };
  return {
          isSigned: true,
          isUnsigned: isUnsigned,
          bits: bits,
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          zero: 0,
          one: 1,
          minValue: minValue,
          maxValue: maxValue,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          inc: include.inc,
          incExn: include.incExn,
          incUnsafe: include.incUnsafe,
          dec: include.dec,
          decExn: include.decExn,
          decUnsafe: include.decUnsafe,
          sum: include$1.sum,
          sumExn: include$1.sumExn,
          sumUnsafe: include$1.sumUnsafe,
          lnot: lnot,
          land: land,
          lor: lor,
          lxor: lxor,
          lsl: lsl,
          lsr: lsr,
          asr: asr,
          rlsl: rlsl,
          rlsr: rlsr,
          clz: include$2.clz,
          imul: include$2.imul,
          pow: include$2.pow,
          powExn: include$2.powExn,
          powUnsafe: include$2.powUnsafe,
          random: include$2.random,
          neg: neg,
          negExn: negExn,
          negUnsafe: negUnsafe,
          abs: abs,
          absExn: absExn,
          absUnsafe: absUnsafe,
          sign: sign,
          signExn: signExn,
          signRaw: signRaw
        };
}

function MakeUnsignedInteger(M) {
  var bits = M.bits;
  var minValue = M.minValue;
  var maxValue = M.maxValue;
  var IntRange = {
    minValue: minValue,
    maxValue: maxValue
  };
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromInt = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i;
        }
      });
  var fromIntUnsafe = function (i) {
    return i;
  };
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
    }
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromInt(i);
    }
    
  };
  var fromStringExn = function (s) {
    var i = ResNumber__Utils.stringToInt(s);
    if (i !== undefined) {
      return fromIntExn(i);
    } else {
      return PervasivesU.invalid_arg("the string is not a integer: " + s);
    }
  };
  if (minValue > 0 || maxValue < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue.toString() + " and maxValue " + maxValue.toString());
  }
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]);
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray(undefined);
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]);
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f;
    }
  };
  var isAddMaybeOverflow = minValue + minValue < Js_int.min || maxValue + maxValue > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue - maxValue < Js_int.min || maxValue - minValue > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue * maxValue < Js_int.min || minValue * minValue > Js_int.max || maxValue * maxValue > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = Caml_int32.mod_;
  var include = ResNumber__Operation.MakeNumberIncDec({
        one: 1,
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe,
        sub: sub,
        subExn: subExn,
        subClamped: subClamped,
        subUnsafe: subUnsafe
      });
  var include$1 = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  if (bits <= 0 || bits > 32) {
    PervasivesU.invalid_arg("bits must not be less than 1 or greater than 32: " + bits.toString());
  }
  var isUnsigned = true;
  if (isUnsigned) {
    if (minValue !== 0) {
      PervasivesU.invalid_arg("invalid minValue " + minValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    if (Math.pow(2.0, bits) - 1.0 !== maxValue) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    
  }
  var is32Bits = bits === 32;
  var mask = Math.pow(2.0, bits) - 1.0 | 0;
  PervasivesU.lnot(mask);
  var lnot = isUnsigned ? (function (i) {
        return PervasivesU.lnot(i) & mask;
      }) : PervasivesU.lnot;
  var land = function (prim0, prim1) {
    return prim0 & prim1;
  };
  var lor = function (prim0, prim1) {
    return prim0 | prim1;
  };
  var lxor = function (prim0, prim1) {
    return prim0 ^ prim1;
  };
  var modBits = function (n) {
    if (n < 0 || n >= bits) {
      return toUint32(n) % bits;
    } else {
      return n;
    }
  };
  var lsl = is32Bits ? (function (prim0, prim1) {
        return (prim0 << prim1);
      }) : (function (i, n) {
        return (i << modBits(n)) & mask;
      });
  var lsr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >>> prim1) | 0;
      }) : (function (i, n) {
        return (i >>> modBits(n)) | 0;
      });
  var asr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >> prim1);
      }) : (function (i, n) {
        return (i >> modBits(n));
      });
  var rlsl = function (i, n) {
    var m = modBits(n);
    return lsl(i, m) | lsr(i, bits - m | 0);
  };
  var rlsr = function (i, n) {
    var m = modBits(n);
    return lsr(i, m) | lsl(i, bits - m | 0);
  };
  var clz = is32Bits ? (function (i) {
        return Math.clz32(i);
      }) : (function (i) {
        var c = Math.clz32(i);
        if (c > 0) {
          return c - (32 - bits | 0) | 0;
        } else {
          return c;
        }
      });
  var imul = is32Bits ? (function (a, b) {
        return Math.imul(a, b);
      }) : (function (a, b) {
        return Math.imul(a, b) & mask;
      });
  var include$2 = ResNumber__Math.MakeIntegerMath({
        fromFloat: fromFloat,
        fromFloatExn: fromFloatExn,
        fromFloatClamped: fromFloatClamped,
        fromFloatUnsafe: fromFloatUnsafe,
        toFloat: toFloat,
        clz: clz,
        imul: imul
      });
  return {
          isSigned: false,
          isUnsigned: isUnsigned,
          bits: bits,
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          zero: 0,
          one: 1,
          minValue: minValue,
          maxValue: maxValue,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          inc: include.inc,
          incExn: include.incExn,
          incUnsafe: include.incUnsafe,
          dec: include.dec,
          decExn: include.decExn,
          decUnsafe: include.decUnsafe,
          sum: include$1.sum,
          sumExn: include$1.sumExn,
          sumUnsafe: include$1.sumUnsafe,
          lnot: lnot,
          land: land,
          lor: lor,
          lxor: lxor,
          lsl: lsl,
          lsr: lsr,
          asr: asr,
          rlsl: rlsl,
          rlsr: rlsr,
          clz: include$2.clz,
          imul: include$2.imul,
          pow: include$2.pow,
          powExn: include$2.powExn,
          powUnsafe: include$2.powUnsafe,
          random: include$2.random
        };
}

var IntRange = {
  minValue: -128,
  maxValue: 127
};

function toString(i) {
  return i.toString();
}

if (-128 < Js_int.min || 127 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (-128).toString() + ", maxValue: " + (127).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32 = -128 === Js_int.min && 127 === Js_int.max;

var fromInt = isInt32 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= -128 && i <= 127) {
        return i;
      }
      
    });

var fromIntExn = isInt32 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= -128 && i <= 127) {
        return i;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange);
      }
    });

var fromIntClamped = isInt32 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i < -128) {
        return -128;
      } else if (i > 127) {
        return 127;
      } else {
        return i;
      }
    });

function fromIntUnsafe(i) {
  return i;
}

function toInt(i) {
  return i;
}

function toIntExn(i) {
  return i;
}

function toIntClamped(i) {
  return i;
}

function toIntUnsafe(i) {
  return i;
}

function fromFloat(f) {
  if (Number.isInteger(f) && f >= -128 && f <= 127) {
    return f;
  }
  
}

function fromFloatExn(f) {
  if (Number.isInteger(f)) {
    if (f < -128 || f > 127) {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    } else {
      return f;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
  }
}

function fromFloatUnsafe(f) {
  return f | 0;
}

function fromFloatClamped(f) {
  if (f < -128) {
    return -128;
  } else if (f > 127) {
    return 127;
  } else {
    return f | 0;
  }
}

function toFloat(i) {
  return i;
}

function fromString(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromInt(i);
  }
  
}

function fromStringExn(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromIntExn(i);
  } else {
    return PervasivesU.invalid_arg("the string is not a integer: " + s);
  }
}

function compareExn(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare(a, b) {
  return compareExn(a, b);
}

function eq(a, b) {
  return a === b;
}

function ne(a, b) {
  return a !== b;
}

function lt(a, b) {
  return a < b;
}

function le(a, b) {
  return a <= b;
}

function gt(a, b) {
  return a > b;
}

function ge(a, b) {
  return a >= b;
}

function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function minManyUnsafe(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]);
}

function max(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function maxManyUnsafe(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]);
}

function fromFloatUncheckInteger(f) {
  if (f >= -128 && f <= 127) {
    return f;
  }
  
}

function fromFloatUncheckIntegerExn(f) {
  if (f >= -128 && f <= 127) {
    return f;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange);
  }
}

function fromFloatUncheckIntegerClamped(f) {
  if (f < -128) {
    return -128;
  } else if (f > 127) {
    return 127;
  } else {
    return f;
  }
}

var isAddMaybeOverflow = -256 < Js_int.min || 254 > Js_int.max;

function addUnsafe(a, b) {
  return a + b | 0;
}

var add = isAddMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckInteger(a + b);
    }) : (function (a, b) {
      return fromInt(a + b | 0);
    });

var addExn = isAddMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerExn(a + b);
    }) : (function (a, b) {
      return fromIntExn(a + b | 0);
    });

var addClamped = isAddMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerClamped(a + b);
    }) : (function (a, b) {
      return fromIntClamped(a + b | 0);
    });

var isSubMaybeOverflow = -255 < Js_int.min || 255 > Js_int.max;

function subUnsafe(a, b) {
  return a - b | 0;
}

var sub = isSubMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckInteger(a - b);
    }) : (function (a, b) {
      return fromInt(a - b | 0);
    });

var subExn = isSubMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerExn(a - b);
    }) : (function (a, b) {
      return fromIntExn(a - b | 0);
    });

var subClamped = isSubMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerClamped(a - b);
    }) : (function (a, b) {
      return fromIntClamped(a - b | 0);
    });

var isMulMaybeOverflow = -128 * 127 < Js_int.min || -128 * -128 > Js_int.max || 127 * 127 > Js_int.max;

function mulUnsafe(a, b) {
  return Math.imul(a, b);
}

var mul = isMulMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckInteger(a * b);
    }) : (function (a, b) {
      return fromInt(Math.imul(a, b));
    });

var mulExn = isMulMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerExn(a * b);
    }) : (function (a, b) {
      return fromIntExn(Math.imul(a, b));
    });

var mulClamped = isMulMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerClamped(a * b);
    }) : (function (a, b) {
      return fromIntClamped(Math.imul(a, b));
    });

function divUnsafe(a, b) {
  return a / b | 0;
}

function div(a, b) {
  if (b !== 0) {
    return divUnsafe(a, b);
  }
  
}

var divExn = Caml_int32.div;

function remUnsafe(a, b) {
  return a % b | 0;
}

function rem(a, b) {
  if (b !== 0) {
    return remUnsafe(a, b);
  }
  
}

var remExn = Caml_int32.mod_;

var include = ResNumber__Operation.MakeNumberIncDec({
      one: 1,
      add: add,
      addExn: addExn,
      addClamped: addClamped,
      addUnsafe: addUnsafe,
      sub: sub,
      subExn: subExn,
      subClamped: subClamped,
      subUnsafe: subUnsafe
    });

var include$1 = ResNumber__Operation.MakeNumberSum({
      add: add,
      addExn: addExn,
      addClamped: addClamped,
      addUnsafe: addUnsafe
    });

var isUnsigned = false;

var n = toUint32(-128);

if (Math.log2(n) !== 7) {
  PervasivesU.invalid_arg("invalid minValue " + (-128).toString() + " for " + (8).toString() + " bits signed integer");
}

if (n - 1.0 !== 127) {
  PervasivesU.invalid_arg("invalid maxValue " + (127).toString() + " for " + (8).toString() + " bits signed integer");
}

if (isUnsigned) {
  PervasivesU.invalid_arg("invalid minValue " + (-128).toString() + " for " + (8).toString() + " bits unsigned integer");
  if (Math.pow(2.0, 8) - 1.0 !== 127) {
    PervasivesU.invalid_arg("invalid maxValue " + (127).toString() + " for " + (8).toString() + " bits unsigned integer");
  }
  
}

var is32Bits = false;

var mask = Math.pow(2.0, 8) - 1.0 | 0;

var maskNot = PervasivesU.lnot(mask);

var highestBit = 128;

var lnot = isUnsigned ? (function (i) {
      return PervasivesU.lnot(i) & mask;
    }) : PervasivesU.lnot;

function land(prim0, prim1) {
  return prim0 & prim1;
}

function lor(prim0, prim1) {
  return prim0 | prim1;
}

function lxor(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits(n) {
  if (n < 0 || n >= 8) {
    return toUint32(n) % 8;
  } else {
    return n;
  }
}

var lsl = is32Bits ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var v = (i << modBits(n));
      if ((v & highestBit) === 0) {
        return v & mask;
      } else {
        return v | maskNot;
      }
    });

var lsr = is32Bits ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return ((i & mask) >>> modBits(n)) | 0;
    });

var asr = is32Bits ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits(n));
    });

function rlsl(i, n) {
  var m = modBits(n);
  return lsl(i, m) | lsr(i, 8 - m | 0);
}

function rlsr(i, n) {
  var m = modBits(n);
  return lsr(i, m) | lsl(i, 8 - m | 0);
}

var clz = is32Bits ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 24 | 0;
      } else {
        return c;
      }
    });

var imul = is32Bits ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      var i = Math.imul(a, b);
      if ((i & highestBit) === 0) {
        return i & mask;
      } else {
        return i | maskNot;
      }
    });

var include$2 = ResNumber__Math.MakeIntegerMath({
      fromFloat: fromFloat,
      fromFloatExn: fromFloatExn,
      fromFloatClamped: fromFloatClamped,
      fromFloatUnsafe: fromFloatUnsafe,
      toFloat: toFloat,
      clz: clz,
      imul: imul
    });

function neg(i) {
  if (i !== -128) {
    return -i | 0;
  }
  
}

function negExn(i) {
  var v = neg(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(- i, {
                minValue: -128,
                maxValue: 127
              });
  }
}

function negUnsafe(i) {
  return -i | 0;
}

function abs(i) {
  if (i !== -128) {
    return Math.abs(i);
  }
  
}

function absExn(i) {
  var v = abs(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                minValue: -128,
                maxValue: 127
              });
  }
}

function absUnsafe(i) {
  return PervasivesU.abs(i);
}

function signExn(i) {
  var match = Math.sign(i);
  switch (match) {
    case -1 :
        return -1;
    case 0 :
        return 0;
    case 1 :
        return 1;
    default:
      return 0;
  }
}

function sign(i) {
  return signExn(i);
}

function signRaw(i) {
  return Math.sign(i);
}

var Int8_inc = include.inc;

var Int8_incExn = include.incExn;

var Int8_incUnsafe = include.incUnsafe;

var Int8_dec = include.dec;

var Int8_decExn = include.decExn;

var Int8_decUnsafe = include.decUnsafe;

var Int8_sum = include$1.sum;

var Int8_sumExn = include$1.sumExn;

var Int8_sumUnsafe = include$1.sumUnsafe;

var Int8_clz = include$2.clz;

var Int8_imul = include$2.imul;

var Int8_pow = include$2.pow;

var Int8_powExn = include$2.powExn;

var Int8_powUnsafe = include$2.powUnsafe;

var Int8_random = include$2.random;

var Int8 = {
  isSigned: true,
  isUnsigned: isUnsigned,
  bits: 8,
  fromInt: fromInt,
  fromIntExn: fromIntExn,
  fromIntClamped: fromIntClamped,
  fromIntUnsafe: fromIntUnsafe,
  toInt: toInt,
  toIntExn: toIntExn,
  toIntClamped: toIntClamped,
  toIntUnsafe: toIntUnsafe,
  fromFloat: fromFloat,
  fromFloatExn: fromFloatExn,
  fromFloatClamped: fromFloatClamped,
  fromFloatUnsafe: fromFloatUnsafe,
  toFloat: toFloat,
  fromString: fromString,
  fromStringExn: fromStringExn,
  toString: toString,
  zero: 0,
  one: 1,
  minValue: -128,
  maxValue: 127,
  compare: compare,
  compareExn: compareExn,
  eq: eq,
  ne: ne,
  lt: lt,
  le: le,
  gt: gt,
  ge: ge,
  min: min,
  minMany: minMany,
  minManyExn: minManyExn,
  minManyUnsafe: minManyUnsafe,
  max: max,
  maxMany: maxMany,
  maxManyExn: maxManyExn,
  maxManyUnsafe: maxManyUnsafe,
  add: add,
  addExn: addExn,
  addClamped: addClamped,
  addUnsafe: addUnsafe,
  sub: sub,
  subExn: subExn,
  subClamped: subClamped,
  subUnsafe: subUnsafe,
  mul: mul,
  mulExn: mulExn,
  mulClamped: mulClamped,
  mulUnsafe: mulUnsafe,
  div: div,
  divExn: divExn,
  divUnsafe: divUnsafe,
  rem: rem,
  remExn: remExn,
  remUnsafe: remUnsafe,
  inc: Int8_inc,
  incExn: Int8_incExn,
  incUnsafe: Int8_incUnsafe,
  dec: Int8_dec,
  decExn: Int8_decExn,
  decUnsafe: Int8_decUnsafe,
  sum: Int8_sum,
  sumExn: Int8_sumExn,
  sumUnsafe: Int8_sumUnsafe,
  lnot: lnot,
  land: land,
  lor: lor,
  lxor: lxor,
  lsl: lsl,
  lsr: lsr,
  asr: asr,
  rlsl: rlsl,
  rlsr: rlsr,
  clz: Int8_clz,
  imul: Int8_imul,
  pow: Int8_pow,
  powExn: Int8_powExn,
  powUnsafe: Int8_powUnsafe,
  random: Int8_random,
  neg: neg,
  negExn: negExn,
  negUnsafe: negUnsafe,
  abs: abs,
  absExn: absExn,
  absUnsafe: absUnsafe,
  sign: sign,
  signExn: signExn,
  signRaw: signRaw
};

var IntRange$1 = {
  minValue: 0,
  maxValue: 255
};

function toString$1(i) {
  return i.toString();
}

if (0 < Js_int.min || 255 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (0).toString() + ", maxValue: " + (255).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$1 = 0 === Js_int.min && 255 === Js_int.max;

var fromInt$1 = isInt32$1 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= 0 && i <= 255) {
        return i;
      }
      
    });

var fromIntExn$1 = isInt32$1 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= 0 && i <= 255) {
        return i;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$1);
      }
    });

var fromIntClamped$1 = isInt32$1 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i < 0) {
        return 0;
      } else if (i > 255) {
        return 255;
      } else {
        return i;
      }
    });

function fromIntUnsafe$1(i) {
  return i;
}

function toInt$1(i) {
  return i;
}

function toIntExn$1(i) {
  return i;
}

function toIntClamped$1(i) {
  return i;
}

function toIntUnsafe$1(i) {
  return i;
}

function fromFloat$1(f) {
  if (Number.isInteger(f) && f >= 0 && f <= 255) {
    return f;
  }
  
}

function fromFloatExn$1(f) {
  if (Number.isInteger(f)) {
    if (f < 0 || f > 255) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$1);
    } else {
      return f;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
  }
}

function fromFloatUnsafe$1(f) {
  return f | 0;
}

function fromFloatClamped$1(f) {
  if (f < 0) {
    return 0;
  } else if (f > 255) {
    return 255;
  } else {
    return f | 0;
  }
}

function toFloat$1(i) {
  return i;
}

function fromString$1(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromInt$1(i);
  }
  
}

function fromStringExn$1(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromIntExn$1(i);
  } else {
    return PervasivesU.invalid_arg("the string is not a integer: " + s);
  }
}

function compareExn$1(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$1(a, b) {
  return compareExn$1(a, b);
}

function eq$1(a, b) {
  return a === b;
}

function ne$1(a, b) {
  return a !== b;
}

function lt$1(a, b) {
  return a < b;
}

function le$1(a, b) {
  return a <= b;
}

function gt$1(a, b) {
  return a > b;
}

function ge$1(a, b) {
  return a >= b;
}

function min$1(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$1(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$1(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function minManyUnsafe$1(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]);
}

function max$1(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$1(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$1(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function maxManyUnsafe$1(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]);
}

function fromFloatUncheckInteger$1(f) {
  if (f >= 0 && f <= 255) {
    return f;
  }
  
}

function fromFloatUncheckIntegerExn$1(f) {
  if (f >= 0 && f <= 255) {
    return f;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$1);
  }
}

function fromFloatUncheckIntegerClamped$1(f) {
  if (f < 0) {
    return 0;
  } else if (f > 255) {
    return 255;
  } else {
    return f;
  }
}

var isAddMaybeOverflow$1 = 0 < Js_int.min || 510 > Js_int.max;

function addUnsafe$1(a, b) {
  return a + b | 0;
}

var add$1 = isAddMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckInteger$1(a + b);
    }) : (function (a, b) {
      return fromInt$1(a + b | 0);
    });

var addExn$1 = isAddMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$1(a + b);
    }) : (function (a, b) {
      return fromIntExn$1(a + b | 0);
    });

var addClamped$1 = isAddMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$1(a + b);
    }) : (function (a, b) {
      return fromIntClamped$1(a + b | 0);
    });

var isSubMaybeOverflow$1 = -255 < Js_int.min || 255 > Js_int.max;

function subUnsafe$1(a, b) {
  return a - b | 0;
}

var sub$1 = isSubMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckInteger$1(a - b);
    }) : (function (a, b) {
      return fromInt$1(a - b | 0);
    });

var subExn$1 = isSubMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$1(a - b);
    }) : (function (a, b) {
      return fromIntExn$1(a - b | 0);
    });

var subClamped$1 = isSubMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$1(a - b);
    }) : (function (a, b) {
      return fromIntClamped$1(a - b | 0);
    });

var isMulMaybeOverflow$1 = 0 * 255 < Js_int.min || 0 * 0 > Js_int.max || 255 * 255 > Js_int.max;

function mulUnsafe$1(a, b) {
  return Math.imul(a, b);
}

var mul$1 = isMulMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckInteger$1(a * b);
    }) : (function (a, b) {
      return fromInt$1(Math.imul(a, b));
    });

var mulExn$1 = isMulMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$1(a * b);
    }) : (function (a, b) {
      return fromIntExn$1(Math.imul(a, b));
    });

var mulClamped$1 = isMulMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$1(a * b);
    }) : (function (a, b) {
      return fromIntClamped$1(Math.imul(a, b));
    });

function divUnsafe$1(a, b) {
  return a / b | 0;
}

function div$1(a, b) {
  if (b !== 0) {
    return divUnsafe$1(a, b);
  }
  
}

var divExn$1 = Caml_int32.div;

function remUnsafe$1(a, b) {
  return a % b | 0;
}

function rem$1(a, b) {
  if (b !== 0) {
    return remUnsafe$1(a, b);
  }
  
}

var remExn$1 = Caml_int32.mod_;

var include$3 = ResNumber__Operation.MakeNumberIncDec({
      one: 1,
      add: add$1,
      addExn: addExn$1,
      addClamped: addClamped$1,
      addUnsafe: addUnsafe$1,
      sub: sub$1,
      subExn: subExn$1,
      subClamped: subClamped$1,
      subUnsafe: subUnsafe$1
    });

var include$4 = ResNumber__Operation.MakeNumberSum({
      add: add$1,
      addExn: addExn$1,
      addClamped: addClamped$1,
      addUnsafe: addUnsafe$1
    });

var isUnsigned$1 = true;

if (isUnsigned$1 && Math.pow(2.0, 8) - 1.0 !== 255) {
  PervasivesU.invalid_arg("invalid maxValue " + (255).toString() + " for " + (8).toString() + " bits unsigned integer");
}

var is32Bits$1 = false;

var mask$1 = Math.pow(2.0, 8) - 1.0 | 0;

PervasivesU.lnot(mask$1);

var lnot$1 = isUnsigned$1 ? (function (i) {
      return PervasivesU.lnot(i) & mask$1;
    }) : PervasivesU.lnot;

function land$1(prim0, prim1) {
  return prim0 & prim1;
}

function lor$1(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$1(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$1(n) {
  if (n < 0 || n >= 8) {
    return toUint32(n) % 8;
  } else {
    return n;
  }
}

var lsl$1 = is32Bits$1 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      return (i << modBits$1(n)) & mask$1;
    });

var lsr$1 = is32Bits$1 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return (i >>> modBits$1(n)) | 0;
    });

var asr$1 = is32Bits$1 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$1(n));
    });

function rlsl$1(i, n) {
  var m = modBits$1(n);
  return lsl$1(i, m) | lsr$1(i, 8 - m | 0);
}

function rlsr$1(i, n) {
  var m = modBits$1(n);
  return lsr$1(i, m) | lsl$1(i, 8 - m | 0);
}

var clz$1 = is32Bits$1 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 24 | 0;
      } else {
        return c;
      }
    });

var imul$1 = is32Bits$1 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      return Math.imul(a, b) & mask$1;
    });

var include$5 = ResNumber__Math.MakeIntegerMath({
      fromFloat: fromFloat$1,
      fromFloatExn: fromFloatExn$1,
      fromFloatClamped: fromFloatClamped$1,
      fromFloatUnsafe: fromFloatUnsafe$1,
      toFloat: toFloat$1,
      clz: clz$1,
      imul: imul$1
    });

var Uint8_inc = include$3.inc;

var Uint8_incExn = include$3.incExn;

var Uint8_incUnsafe = include$3.incUnsafe;

var Uint8_dec = include$3.dec;

var Uint8_decExn = include$3.decExn;

var Uint8_decUnsafe = include$3.decUnsafe;

var Uint8_sum = include$4.sum;

var Uint8_sumExn = include$4.sumExn;

var Uint8_sumUnsafe = include$4.sumUnsafe;

var Uint8_clz = include$5.clz;

var Uint8_imul = include$5.imul;

var Uint8_pow = include$5.pow;

var Uint8_powExn = include$5.powExn;

var Uint8_powUnsafe = include$5.powUnsafe;

var Uint8_random = include$5.random;

var Uint8 = {
  isSigned: false,
  isUnsigned: isUnsigned$1,
  bits: 8,
  fromInt: fromInt$1,
  fromIntExn: fromIntExn$1,
  fromIntClamped: fromIntClamped$1,
  fromIntUnsafe: fromIntUnsafe$1,
  toInt: toInt$1,
  toIntExn: toIntExn$1,
  toIntClamped: toIntClamped$1,
  toIntUnsafe: toIntUnsafe$1,
  fromFloat: fromFloat$1,
  fromFloatExn: fromFloatExn$1,
  fromFloatClamped: fromFloatClamped$1,
  fromFloatUnsafe: fromFloatUnsafe$1,
  toFloat: toFloat$1,
  fromString: fromString$1,
  fromStringExn: fromStringExn$1,
  toString: toString$1,
  zero: 0,
  one: 1,
  minValue: 0,
  maxValue: 255,
  compare: compare$1,
  compareExn: compareExn$1,
  eq: eq$1,
  ne: ne$1,
  lt: lt$1,
  le: le$1,
  gt: gt$1,
  ge: ge$1,
  min: min$1,
  minMany: minMany$1,
  minManyExn: minManyExn$1,
  minManyUnsafe: minManyUnsafe$1,
  max: max$1,
  maxMany: maxMany$1,
  maxManyExn: maxManyExn$1,
  maxManyUnsafe: maxManyUnsafe$1,
  add: add$1,
  addExn: addExn$1,
  addClamped: addClamped$1,
  addUnsafe: addUnsafe$1,
  sub: sub$1,
  subExn: subExn$1,
  subClamped: subClamped$1,
  subUnsafe: subUnsafe$1,
  mul: mul$1,
  mulExn: mulExn$1,
  mulClamped: mulClamped$1,
  mulUnsafe: mulUnsafe$1,
  div: div$1,
  divExn: divExn$1,
  divUnsafe: divUnsafe$1,
  rem: rem$1,
  remExn: remExn$1,
  remUnsafe: remUnsafe$1,
  inc: Uint8_inc,
  incExn: Uint8_incExn,
  incUnsafe: Uint8_incUnsafe,
  dec: Uint8_dec,
  decExn: Uint8_decExn,
  decUnsafe: Uint8_decUnsafe,
  sum: Uint8_sum,
  sumExn: Uint8_sumExn,
  sumUnsafe: Uint8_sumUnsafe,
  lnot: lnot$1,
  land: land$1,
  lor: lor$1,
  lxor: lxor$1,
  lsl: lsl$1,
  lsr: lsr$1,
  asr: asr$1,
  rlsl: rlsl$1,
  rlsr: rlsr$1,
  clz: Uint8_clz,
  imul: Uint8_imul,
  pow: Uint8_pow,
  powExn: Uint8_powExn,
  powUnsafe: Uint8_powUnsafe,
  random: Uint8_random
};

var IntRange$2 = {
  minValue: -32768,
  maxValue: 32767
};

function toString$2(i) {
  return i.toString();
}

if (-32768 < Js_int.min || 32767 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (-32768).toString() + ", maxValue: " + (32767).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$2 = -32768 === Js_int.min && 32767 === Js_int.max;

var fromInt$2 = isInt32$2 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= -32768 && i <= 32767) {
        return i;
      }
      
    });

var fromIntExn$2 = isInt32$2 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= -32768 && i <= 32767) {
        return i;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$2);
      }
    });

var fromIntClamped$2 = isInt32$2 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i < -32768) {
        return -32768;
      } else if (i > 32767) {
        return 32767;
      } else {
        return i;
      }
    });

function fromIntUnsafe$2(i) {
  return i;
}

function toInt$2(i) {
  return i;
}

function toIntExn$2(i) {
  return i;
}

function toIntClamped$2(i) {
  return i;
}

function toIntUnsafe$2(i) {
  return i;
}

function fromFloat$2(f) {
  if (Number.isInteger(f) && f >= -32768 && f <= 32767) {
    return f;
  }
  
}

function fromFloatExn$2(f) {
  if (Number.isInteger(f)) {
    if (f < -32768 || f > 32767) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$2);
    } else {
      return f;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
  }
}

function fromFloatUnsafe$2(f) {
  return f | 0;
}

function fromFloatClamped$2(f) {
  if (f < -32768) {
    return -32768;
  } else if (f > 32767) {
    return 32767;
  } else {
    return f | 0;
  }
}

function toFloat$2(i) {
  return i;
}

function fromString$2(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromInt$2(i);
  }
  
}

function fromStringExn$2(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromIntExn$2(i);
  } else {
    return PervasivesU.invalid_arg("the string is not a integer: " + s);
  }
}

function compareExn$2(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$2(a, b) {
  return compareExn$2(a, b);
}

function eq$2(a, b) {
  return a === b;
}

function ne$2(a, b) {
  return a !== b;
}

function lt$2(a, b) {
  return a < b;
}

function le$2(a, b) {
  return a <= b;
}

function gt$2(a, b) {
  return a > b;
}

function ge$2(a, b) {
  return a >= b;
}

function min$2(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$2(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$2(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function minManyUnsafe$2(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]);
}

function max$2(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$2(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$2(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function maxManyUnsafe$2(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]);
}

function fromFloatUncheckInteger$2(f) {
  if (f >= -32768 && f <= 32767) {
    return f;
  }
  
}

function fromFloatUncheckIntegerExn$2(f) {
  if (f >= -32768 && f <= 32767) {
    return f;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$2);
  }
}

function fromFloatUncheckIntegerClamped$2(f) {
  if (f < -32768) {
    return -32768;
  } else if (f > 32767) {
    return 32767;
  } else {
    return f;
  }
}

var isAddMaybeOverflow$2 = -65536 < Js_int.min || 65534 > Js_int.max;

function addUnsafe$2(a, b) {
  return a + b | 0;
}

var add$2 = isAddMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckInteger$2(a + b);
    }) : (function (a, b) {
      return fromInt$2(a + b | 0);
    });

var addExn$2 = isAddMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$2(a + b);
    }) : (function (a, b) {
      return fromIntExn$2(a + b | 0);
    });

var addClamped$2 = isAddMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$2(a + b);
    }) : (function (a, b) {
      return fromIntClamped$2(a + b | 0);
    });

var isSubMaybeOverflow$2 = -65535 < Js_int.min || 65535 > Js_int.max;

function subUnsafe$2(a, b) {
  return a - b | 0;
}

var sub$2 = isSubMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckInteger$2(a - b);
    }) : (function (a, b) {
      return fromInt$2(a - b | 0);
    });

var subExn$2 = isSubMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$2(a - b);
    }) : (function (a, b) {
      return fromIntExn$2(a - b | 0);
    });

var subClamped$2 = isSubMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$2(a - b);
    }) : (function (a, b) {
      return fromIntClamped$2(a - b | 0);
    });

var isMulMaybeOverflow$2 = -32768 * 32767 < Js_int.min || -32768 * -32768 > Js_int.max || 32767 * 32767 > Js_int.max;

function mulUnsafe$2(a, b) {
  return Math.imul(a, b);
}

var mul$2 = isMulMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckInteger$2(a * b);
    }) : (function (a, b) {
      return fromInt$2(Math.imul(a, b));
    });

var mulExn$2 = isMulMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$2(a * b);
    }) : (function (a, b) {
      return fromIntExn$2(Math.imul(a, b));
    });

var mulClamped$2 = isMulMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$2(a * b);
    }) : (function (a, b) {
      return fromIntClamped$2(Math.imul(a, b));
    });

function divUnsafe$2(a, b) {
  return a / b | 0;
}

function div$2(a, b) {
  if (b !== 0) {
    return divUnsafe$2(a, b);
  }
  
}

var divExn$2 = Caml_int32.div;

function remUnsafe$2(a, b) {
  return a % b | 0;
}

function rem$2(a, b) {
  if (b !== 0) {
    return remUnsafe$2(a, b);
  }
  
}

var remExn$2 = Caml_int32.mod_;

var include$6 = ResNumber__Operation.MakeNumberIncDec({
      one: 1,
      add: add$2,
      addExn: addExn$2,
      addClamped: addClamped$2,
      addUnsafe: addUnsafe$2,
      sub: sub$2,
      subExn: subExn$2,
      subClamped: subClamped$2,
      subUnsafe: subUnsafe$2
    });

var include$7 = ResNumber__Operation.MakeNumberSum({
      add: add$2,
      addExn: addExn$2,
      addClamped: addClamped$2,
      addUnsafe: addUnsafe$2
    });

var isUnsigned$2 = false;

var n$1 = toUint32(-32768);

if (Math.log2(n$1) !== 15) {
  PervasivesU.invalid_arg("invalid minValue " + (-32768).toString() + " for " + (16).toString() + " bits signed integer");
}

if (n$1 - 1.0 !== 32767) {
  PervasivesU.invalid_arg("invalid maxValue " + (32767).toString() + " for " + (16).toString() + " bits signed integer");
}

if (isUnsigned$2) {
  PervasivesU.invalid_arg("invalid minValue " + (-32768).toString() + " for " + (16).toString() + " bits unsigned integer");
  if (Math.pow(2.0, 16) - 1.0 !== 32767) {
    PervasivesU.invalid_arg("invalid maxValue " + (32767).toString() + " for " + (16).toString() + " bits unsigned integer");
  }
  
}

var is32Bits$2 = false;

var mask$2 = Math.pow(2.0, 16) - 1.0 | 0;

var maskNot$1 = PervasivesU.lnot(mask$2);

var highestBit$1 = 32768;

var lnot$2 = isUnsigned$2 ? (function (i) {
      return PervasivesU.lnot(i) & mask$2;
    }) : PervasivesU.lnot;

function land$2(prim0, prim1) {
  return prim0 & prim1;
}

function lor$2(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$2(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$2(n) {
  if (n < 0 || n >= 16) {
    return toUint32(n) % 16;
  } else {
    return n;
  }
}

var lsl$2 = is32Bits$2 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var v = (i << modBits$2(n));
      if ((v & highestBit$1) === 0) {
        return v & mask$2;
      } else {
        return v | maskNot$1;
      }
    });

var lsr$2 = is32Bits$2 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return ((i & mask$2) >>> modBits$2(n)) | 0;
    });

var asr$2 = is32Bits$2 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$2(n));
    });

function rlsl$2(i, n) {
  var m = modBits$2(n);
  return lsl$2(i, m) | lsr$2(i, 16 - m | 0);
}

function rlsr$2(i, n) {
  var m = modBits$2(n);
  return lsr$2(i, m) | lsl$2(i, 16 - m | 0);
}

var clz$2 = is32Bits$2 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 16 | 0;
      } else {
        return c;
      }
    });

var imul$2 = is32Bits$2 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      var i = Math.imul(a, b);
      if ((i & highestBit$1) === 0) {
        return i & mask$2;
      } else {
        return i | maskNot$1;
      }
    });

var include$8 = ResNumber__Math.MakeIntegerMath({
      fromFloat: fromFloat$2,
      fromFloatExn: fromFloatExn$2,
      fromFloatClamped: fromFloatClamped$2,
      fromFloatUnsafe: fromFloatUnsafe$2,
      toFloat: toFloat$2,
      clz: clz$2,
      imul: imul$2
    });

function neg$1(i) {
  if (i !== -32768) {
    return -i | 0;
  }
  
}

function negExn$1(i) {
  var v = neg$1(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(- i, {
                minValue: -32768,
                maxValue: 32767
              });
  }
}

function negUnsafe$1(i) {
  return -i | 0;
}

function abs$1(i) {
  if (i !== -32768) {
    return Math.abs(i);
  }
  
}

function absExn$1(i) {
  var v = abs$1(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                minValue: -32768,
                maxValue: 32767
              });
  }
}

function absUnsafe$1(i) {
  return PervasivesU.abs(i);
}

function signExn$1(i) {
  var match = Math.sign(i);
  switch (match) {
    case -1 :
        return -1;
    case 0 :
        return 0;
    case 1 :
        return 1;
    default:
      return 0;
  }
}

function sign$1(i) {
  return signExn$1(i);
}

function signRaw$1(i) {
  return Math.sign(i);
}

var Int16_inc = include$6.inc;

var Int16_incExn = include$6.incExn;

var Int16_incUnsafe = include$6.incUnsafe;

var Int16_dec = include$6.dec;

var Int16_decExn = include$6.decExn;

var Int16_decUnsafe = include$6.decUnsafe;

var Int16_sum = include$7.sum;

var Int16_sumExn = include$7.sumExn;

var Int16_sumUnsafe = include$7.sumUnsafe;

var Int16_clz = include$8.clz;

var Int16_imul = include$8.imul;

var Int16_pow = include$8.pow;

var Int16_powExn = include$8.powExn;

var Int16_powUnsafe = include$8.powUnsafe;

var Int16_random = include$8.random;

var Int16 = {
  isSigned: true,
  isUnsigned: isUnsigned$2,
  bits: 16,
  fromInt: fromInt$2,
  fromIntExn: fromIntExn$2,
  fromIntClamped: fromIntClamped$2,
  fromIntUnsafe: fromIntUnsafe$2,
  toInt: toInt$2,
  toIntExn: toIntExn$2,
  toIntClamped: toIntClamped$2,
  toIntUnsafe: toIntUnsafe$2,
  fromFloat: fromFloat$2,
  fromFloatExn: fromFloatExn$2,
  fromFloatClamped: fromFloatClamped$2,
  fromFloatUnsafe: fromFloatUnsafe$2,
  toFloat: toFloat$2,
  fromString: fromString$2,
  fromStringExn: fromStringExn$2,
  toString: toString$2,
  zero: 0,
  one: 1,
  minValue: -32768,
  maxValue: 32767,
  compare: compare$2,
  compareExn: compareExn$2,
  eq: eq$2,
  ne: ne$2,
  lt: lt$2,
  le: le$2,
  gt: gt$2,
  ge: ge$2,
  min: min$2,
  minMany: minMany$2,
  minManyExn: minManyExn$2,
  minManyUnsafe: minManyUnsafe$2,
  max: max$2,
  maxMany: maxMany$2,
  maxManyExn: maxManyExn$2,
  maxManyUnsafe: maxManyUnsafe$2,
  add: add$2,
  addExn: addExn$2,
  addClamped: addClamped$2,
  addUnsafe: addUnsafe$2,
  sub: sub$2,
  subExn: subExn$2,
  subClamped: subClamped$2,
  subUnsafe: subUnsafe$2,
  mul: mul$2,
  mulExn: mulExn$2,
  mulClamped: mulClamped$2,
  mulUnsafe: mulUnsafe$2,
  div: div$2,
  divExn: divExn$2,
  divUnsafe: divUnsafe$2,
  rem: rem$2,
  remExn: remExn$2,
  remUnsafe: remUnsafe$2,
  inc: Int16_inc,
  incExn: Int16_incExn,
  incUnsafe: Int16_incUnsafe,
  dec: Int16_dec,
  decExn: Int16_decExn,
  decUnsafe: Int16_decUnsafe,
  sum: Int16_sum,
  sumExn: Int16_sumExn,
  sumUnsafe: Int16_sumUnsafe,
  lnot: lnot$2,
  land: land$2,
  lor: lor$2,
  lxor: lxor$2,
  lsl: lsl$2,
  lsr: lsr$2,
  asr: asr$2,
  rlsl: rlsl$2,
  rlsr: rlsr$2,
  clz: Int16_clz,
  imul: Int16_imul,
  pow: Int16_pow,
  powExn: Int16_powExn,
  powUnsafe: Int16_powUnsafe,
  random: Int16_random,
  neg: neg$1,
  negExn: negExn$1,
  negUnsafe: negUnsafe$1,
  abs: abs$1,
  absExn: absExn$1,
  absUnsafe: absUnsafe$1,
  sign: sign$1,
  signExn: signExn$1,
  signRaw: signRaw$1
};

var IntRange$3 = {
  minValue: 0,
  maxValue: 65535
};

function toString$3(i) {
  return i.toString();
}

if (0 < Js_int.min || 65535 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (0).toString() + ", maxValue: " + (65535).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$3 = 0 === Js_int.min && 65535 === Js_int.max;

var fromInt$3 = isInt32$3 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= 0 && i <= 65535) {
        return i;
      }
      
    });

var fromIntExn$3 = isInt32$3 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= 0 && i <= 65535) {
        return i;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$3);
      }
    });

var fromIntClamped$3 = isInt32$3 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i < 0) {
        return 0;
      } else if (i > 65535) {
        return 65535;
      } else {
        return i;
      }
    });

function fromIntUnsafe$3(i) {
  return i;
}

function toInt$3(i) {
  return i;
}

function toIntExn$3(i) {
  return i;
}

function toIntClamped$3(i) {
  return i;
}

function toIntUnsafe$3(i) {
  return i;
}

function fromFloat$3(f) {
  if (Number.isInteger(f) && f >= 0 && f <= 65535) {
    return f;
  }
  
}

function fromFloatExn$3(f) {
  if (Number.isInteger(f)) {
    if (f < 0 || f > 65535) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$3);
    } else {
      return f;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
  }
}

function fromFloatUnsafe$3(f) {
  return f | 0;
}

function fromFloatClamped$3(f) {
  if (f < 0) {
    return 0;
  } else if (f > 65535) {
    return 65535;
  } else {
    return f | 0;
  }
}

function toFloat$3(i) {
  return i;
}

function fromString$3(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromInt$3(i);
  }
  
}

function fromStringExn$3(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromIntExn$3(i);
  } else {
    return PervasivesU.invalid_arg("the string is not a integer: " + s);
  }
}

function compareExn$3(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$3(a, b) {
  return compareExn$3(a, b);
}

function eq$3(a, b) {
  return a === b;
}

function ne$3(a, b) {
  return a !== b;
}

function lt$3(a, b) {
  return a < b;
}

function le$3(a, b) {
  return a <= b;
}

function gt$3(a, b) {
  return a > b;
}

function ge$3(a, b) {
  return a >= b;
}

function min$3(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$3(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$3(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function minManyUnsafe$3(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]);
}

function max$3(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$3(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$3(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function maxManyUnsafe$3(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]);
}

function fromFloatUncheckInteger$3(f) {
  if (f >= 0 && f <= 65535) {
    return f;
  }
  
}

function fromFloatUncheckIntegerExn$3(f) {
  if (f >= 0 && f <= 65535) {
    return f;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$3);
  }
}

function fromFloatUncheckIntegerClamped$3(f) {
  if (f < 0) {
    return 0;
  } else if (f > 65535) {
    return 65535;
  } else {
    return f;
  }
}

var isAddMaybeOverflow$3 = 0 < Js_int.min || 131070 > Js_int.max;

function addUnsafe$3(a, b) {
  return a + b | 0;
}

var add$3 = isAddMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckInteger$3(a + b);
    }) : (function (a, b) {
      return fromInt$3(a + b | 0);
    });

var addExn$3 = isAddMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$3(a + b);
    }) : (function (a, b) {
      return fromIntExn$3(a + b | 0);
    });

var addClamped$3 = isAddMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$3(a + b);
    }) : (function (a, b) {
      return fromIntClamped$3(a + b | 0);
    });

var isSubMaybeOverflow$3 = -65535 < Js_int.min || 65535 > Js_int.max;

function subUnsafe$3(a, b) {
  return a - b | 0;
}

var sub$3 = isSubMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckInteger$3(a - b);
    }) : (function (a, b) {
      return fromInt$3(a - b | 0);
    });

var subExn$3 = isSubMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$3(a - b);
    }) : (function (a, b) {
      return fromIntExn$3(a - b | 0);
    });

var subClamped$3 = isSubMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$3(a - b);
    }) : (function (a, b) {
      return fromIntClamped$3(a - b | 0);
    });

var isMulMaybeOverflow$3 = 0 * 65535 < Js_int.min || 0 * 0 > Js_int.max || 65535 * 65535 > Js_int.max;

function mulUnsafe$3(a, b) {
  return Math.imul(a, b);
}

var mul$3 = isMulMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckInteger$3(a * b);
    }) : (function (a, b) {
      return fromInt$3(Math.imul(a, b));
    });

var mulExn$3 = isMulMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$3(a * b);
    }) : (function (a, b) {
      return fromIntExn$3(Math.imul(a, b));
    });

var mulClamped$3 = isMulMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$3(a * b);
    }) : (function (a, b) {
      return fromIntClamped$3(Math.imul(a, b));
    });

function divUnsafe$3(a, b) {
  return a / b | 0;
}

function div$3(a, b) {
  if (b !== 0) {
    return divUnsafe$3(a, b);
  }
  
}

var divExn$3 = Caml_int32.div;

function remUnsafe$3(a, b) {
  return a % b | 0;
}

function rem$3(a, b) {
  if (b !== 0) {
    return remUnsafe$3(a, b);
  }
  
}

var remExn$3 = Caml_int32.mod_;

var include$9 = ResNumber__Operation.MakeNumberIncDec({
      one: 1,
      add: add$3,
      addExn: addExn$3,
      addClamped: addClamped$3,
      addUnsafe: addUnsafe$3,
      sub: sub$3,
      subExn: subExn$3,
      subClamped: subClamped$3,
      subUnsafe: subUnsafe$3
    });

var include$10 = ResNumber__Operation.MakeNumberSum({
      add: add$3,
      addExn: addExn$3,
      addClamped: addClamped$3,
      addUnsafe: addUnsafe$3
    });

var isUnsigned$3 = true;

if (isUnsigned$3 && Math.pow(2.0, 16) - 1.0 !== 65535) {
  PervasivesU.invalid_arg("invalid maxValue " + (65535).toString() + " for " + (16).toString() + " bits unsigned integer");
}

var is32Bits$3 = false;

var mask$3 = Math.pow(2.0, 16) - 1.0 | 0;

PervasivesU.lnot(mask$3);

var lnot$3 = isUnsigned$3 ? (function (i) {
      return PervasivesU.lnot(i) & mask$3;
    }) : PervasivesU.lnot;

function land$3(prim0, prim1) {
  return prim0 & prim1;
}

function lor$3(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$3(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$3(n) {
  if (n < 0 || n >= 16) {
    return toUint32(n) % 16;
  } else {
    return n;
  }
}

var lsl$3 = is32Bits$3 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      return (i << modBits$3(n)) & mask$3;
    });

var lsr$3 = is32Bits$3 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return (i >>> modBits$3(n)) | 0;
    });

var asr$3 = is32Bits$3 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$3(n));
    });

function rlsl$3(i, n) {
  var m = modBits$3(n);
  return lsl$3(i, m) | lsr$3(i, 16 - m | 0);
}

function rlsr$3(i, n) {
  var m = modBits$3(n);
  return lsr$3(i, m) | lsl$3(i, 16 - m | 0);
}

var clz$3 = is32Bits$3 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 16 | 0;
      } else {
        return c;
      }
    });

var imul$3 = is32Bits$3 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      return Math.imul(a, b) & mask$3;
    });

var include$11 = ResNumber__Math.MakeIntegerMath({
      fromFloat: fromFloat$3,
      fromFloatExn: fromFloatExn$3,
      fromFloatClamped: fromFloatClamped$3,
      fromFloatUnsafe: fromFloatUnsafe$3,
      toFloat: toFloat$3,
      clz: clz$3,
      imul: imul$3
    });

var Uint16_inc = include$9.inc;

var Uint16_incExn = include$9.incExn;

var Uint16_incUnsafe = include$9.incUnsafe;

var Uint16_dec = include$9.dec;

var Uint16_decExn = include$9.decExn;

var Uint16_decUnsafe = include$9.decUnsafe;

var Uint16_sum = include$10.sum;

var Uint16_sumExn = include$10.sumExn;

var Uint16_sumUnsafe = include$10.sumUnsafe;

var Uint16_clz = include$11.clz;

var Uint16_imul = include$11.imul;

var Uint16_pow = include$11.pow;

var Uint16_powExn = include$11.powExn;

var Uint16_powUnsafe = include$11.powUnsafe;

var Uint16_random = include$11.random;

var Uint16 = {
  isSigned: false,
  isUnsigned: isUnsigned$3,
  bits: 16,
  fromInt: fromInt$3,
  fromIntExn: fromIntExn$3,
  fromIntClamped: fromIntClamped$3,
  fromIntUnsafe: fromIntUnsafe$3,
  toInt: toInt$3,
  toIntExn: toIntExn$3,
  toIntClamped: toIntClamped$3,
  toIntUnsafe: toIntUnsafe$3,
  fromFloat: fromFloat$3,
  fromFloatExn: fromFloatExn$3,
  fromFloatClamped: fromFloatClamped$3,
  fromFloatUnsafe: fromFloatUnsafe$3,
  toFloat: toFloat$3,
  fromString: fromString$3,
  fromStringExn: fromStringExn$3,
  toString: toString$3,
  zero: 0,
  one: 1,
  minValue: 0,
  maxValue: 65535,
  compare: compare$3,
  compareExn: compareExn$3,
  eq: eq$3,
  ne: ne$3,
  lt: lt$3,
  le: le$3,
  gt: gt$3,
  ge: ge$3,
  min: min$3,
  minMany: minMany$3,
  minManyExn: minManyExn$3,
  minManyUnsafe: minManyUnsafe$3,
  max: max$3,
  maxMany: maxMany$3,
  maxManyExn: maxManyExn$3,
  maxManyUnsafe: maxManyUnsafe$3,
  add: add$3,
  addExn: addExn$3,
  addClamped: addClamped$3,
  addUnsafe: addUnsafe$3,
  sub: sub$3,
  subExn: subExn$3,
  subClamped: subClamped$3,
  subUnsafe: subUnsafe$3,
  mul: mul$3,
  mulExn: mulExn$3,
  mulClamped: mulClamped$3,
  mulUnsafe: mulUnsafe$3,
  div: div$3,
  divExn: divExn$3,
  divUnsafe: divUnsafe$3,
  rem: rem$3,
  remExn: remExn$3,
  remUnsafe: remUnsafe$3,
  inc: Uint16_inc,
  incExn: Uint16_incExn,
  incUnsafe: Uint16_incUnsafe,
  dec: Uint16_dec,
  decExn: Uint16_decExn,
  decUnsafe: Uint16_decUnsafe,
  sum: Uint16_sum,
  sumExn: Uint16_sumExn,
  sumUnsafe: Uint16_sumUnsafe,
  lnot: lnot$3,
  land: land$3,
  lor: lor$3,
  lxor: lxor$3,
  lsl: lsl$3,
  lsr: lsr$3,
  asr: asr$3,
  rlsl: rlsl$3,
  rlsr: rlsr$3,
  clz: Uint16_clz,
  imul: Uint16_imul,
  pow: Uint16_pow,
  powExn: Uint16_powExn,
  powUnsafe: Uint16_powUnsafe,
  random: Uint16_random
};

var IntRange$4 = {
  minValue: Js_int.min,
  maxValue: Js_int.max
};

function toString$4(i) {
  return i.toString();
}

if (Js_int.min > Js_int.max) {
  PervasivesU.invalid_arg("minValue " + Js_int.min.toString() + " is greater than maxValue " + Js_int.max.toString());
}

if (Js_int.min < Js_int.min || Js_int.max > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + Js_int.min.toString() + ", maxValue: " + Js_int.max.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$4 = Js_int.min === Js_int.min && Js_int.max === Js_int.max;

var fromInt$4 = isInt32$4 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= Js_int.min && i <= Js_int.max) {
        return i;
      }
      
    });

var fromIntExn$4 = isInt32$4 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i >= Js_int.min && i <= Js_int.max) {
        return i;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$4);
      }
    });

var fromIntClamped$4 = isInt32$4 ? (function (i) {
      return i;
    }) : (function (i) {
      if (i < Js_int.min) {
        return Js_int.min;
      } else if (i > Js_int.max) {
        return Js_int.max;
      } else {
        return i;
      }
    });

function fromIntUnsafe$4(i) {
  return i;
}

function toInt$4(i) {
  return i;
}

function toIntExn$4(i) {
  return i;
}

function toIntClamped$4(i) {
  return i;
}

function toIntUnsafe$4(i) {
  return i;
}

function fromFloat$4(f) {
  if (Number.isInteger(f) && f >= Js_int.min && f <= Js_int.max) {
    return f;
  }
  
}

function fromFloatExn$4(f) {
  if (Number.isInteger(f)) {
    if (f < Js_int.min || f > Js_int.max) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$4);
    } else {
      return f;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
  }
}

function fromFloatUnsafe$4(f) {
  return f | 0;
}

function fromFloatClamped$4(f) {
  if (f < Js_int.min) {
    return Js_int.min;
  } else if (f > Js_int.max) {
    return Js_int.max;
  } else {
    return f | 0;
  }
}

function toFloat$4(i) {
  return i;
}

function fromString$4(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromInt$4(i);
  }
  
}

function fromStringExn$4(s) {
  var i = ResNumber__Utils.stringToInt(s);
  if (i !== undefined) {
    return fromIntExn$4(i);
  } else {
    return PervasivesU.invalid_arg("the string is not a integer: " + s);
  }
}

if (Js_int.min > 0 || Js_int.max < 1) {
  PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + Js_int.min.toString() + " and maxValue " + Js_int.max.toString());
}

function compareExn$4(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$4(a, b) {
  return compareExn$4(a, b);
}

function eq$4(a, b) {
  return a === b;
}

function ne$4(a, b) {
  return a !== b;
}

function lt$4(a, b) {
  return a < b;
}

function le$4(a, b) {
  return a <= b;
}

function gt$4(a, b) {
  return a > b;
}

function ge$4(a, b) {
  return a >= b;
}

function min$4(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$4(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$4(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function minManyUnsafe$4(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]);
}

function max$4(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$4(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$4(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function maxManyUnsafe$4(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]);
}

function fromFloatUncheckInteger$4(f) {
  if (f >= Js_int.min && f <= Js_int.max) {
    return f;
  }
  
}

function fromFloatUncheckIntegerExn$4(f) {
  if (f >= Js_int.min && f <= Js_int.max) {
    return f;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$4);
  }
}

function fromFloatUncheckIntegerClamped$4(f) {
  if (f < Js_int.min) {
    return Js_int.min;
  } else if (f > Js_int.max) {
    return Js_int.max;
  } else {
    return f;
  }
}

var isAddMaybeOverflow$4 = Js_int.min + Js_int.min < Js_int.min || Js_int.max + Js_int.max > Js_int.max;

function addUnsafe$4(a, b) {
  return a + b | 0;
}

var add$4 = isAddMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckInteger$4(a + b);
    }) : (function (a, b) {
      return fromInt$4(a + b | 0);
    });

var addExn$4 = isAddMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$4(a + b);
    }) : (function (a, b) {
      return fromIntExn$4(a + b | 0);
    });

var addClamped$4 = isAddMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$4(a + b);
    }) : (function (a, b) {
      return fromIntClamped$4(a + b | 0);
    });

var isSubMaybeOverflow$4 = Js_int.min - Js_int.max < Js_int.min || Js_int.max - Js_int.min > Js_int.max;

function subUnsafe$4(a, b) {
  return a - b | 0;
}

var sub$4 = isSubMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckInteger$4(a - b);
    }) : (function (a, b) {
      return fromInt$4(a - b | 0);
    });

var subExn$4 = isSubMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$4(a - b);
    }) : (function (a, b) {
      return fromIntExn$4(a - b | 0);
    });

var subClamped$4 = isSubMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$4(a - b);
    }) : (function (a, b) {
      return fromIntClamped$4(a - b | 0);
    });

var isMulMaybeOverflow$4 = Js_int.min * Js_int.max < Js_int.min || Js_int.min * Js_int.min > Js_int.max || Js_int.max * Js_int.max > Js_int.max;

function mulUnsafe$4(a, b) {
  return Math.imul(a, b);
}

var mul$4 = isMulMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckInteger$4(a * b);
    }) : (function (a, b) {
      return fromInt$4(Math.imul(a, b));
    });

var mulExn$4 = isMulMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$4(a * b);
    }) : (function (a, b) {
      return fromIntExn$4(Math.imul(a, b));
    });

var mulClamped$4 = isMulMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$4(a * b);
    }) : (function (a, b) {
      return fromIntClamped$4(Math.imul(a, b));
    });

function divUnsafe$4(a, b) {
  return a / b | 0;
}

function div$4(a, b) {
  if (b !== 0) {
    return divUnsafe$4(a, b);
  }
  
}

var divExn$4 = Caml_int32.div;

function remUnsafe$4(a, b) {
  return a % b | 0;
}

function rem$4(a, b) {
  if (b !== 0) {
    return remUnsafe$4(a, b);
  }
  
}

var remExn$4 = Caml_int32.mod_;

var include$12 = ResNumber__Operation.MakeNumberIncDec({
      one: 1,
      add: add$4,
      addExn: addExn$4,
      addClamped: addClamped$4,
      addUnsafe: addUnsafe$4,
      sub: sub$4,
      subExn: subExn$4,
      subClamped: subClamped$4,
      subUnsafe: subUnsafe$4
    });

var include$13 = ResNumber__Operation.MakeNumberSum({
      add: add$4,
      addExn: addExn$4,
      addClamped: addClamped$4,
      addUnsafe: addUnsafe$4
    });

var isUnsigned$4 = false;

var n$2 = toUint32(Js_int.min);

if (Math.log2(n$2) !== 31) {
  PervasivesU.invalid_arg("invalid minValue " + Js_int.min.toString() + " for " + (32).toString() + " bits signed integer");
}

if (n$2 - 1.0 !== Js_int.max) {
  PervasivesU.invalid_arg("invalid maxValue " + Js_int.max.toString() + " for " + (32).toString() + " bits signed integer");
}

if (isUnsigned$4) {
  if (Js_int.min !== 0) {
    PervasivesU.invalid_arg("invalid minValue " + Js_int.min.toString() + " for " + (32).toString() + " bits unsigned integer");
  }
  if (Math.pow(2.0, 32) - 1.0 !== Js_int.max) {
    PervasivesU.invalid_arg("invalid maxValue " + Js_int.max.toString() + " for " + (32).toString() + " bits unsigned integer");
  }
  
}

var is32Bits$4 = true;

var mask$4 = Math.pow(2.0, 32) - 1.0 | 0;

var maskNot$2 = PervasivesU.lnot(mask$4);

var highestBit$2 = -2147483648;

var lnot$4 = isUnsigned$4 ? (function (i) {
      return PervasivesU.lnot(i) & mask$4;
    }) : PervasivesU.lnot;

function land$4(prim0, prim1) {
  return prim0 & prim1;
}

function lor$4(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$4(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$4(n) {
  if (n < 0 || n >= 32) {
    return toUint32(n) % 32;
  } else {
    return n;
  }
}

var lsl$4 = is32Bits$4 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var v = (i << modBits$4(n));
      if ((v & highestBit$2) === 0) {
        return v & mask$4;
      } else {
        return v | maskNot$2;
      }
    });

var lsr$4 = is32Bits$4 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return ((i & mask$4) >>> modBits$4(n)) | 0;
    });

var asr$4 = is32Bits$4 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$4(n));
    });

function rlsl$4(i, n) {
  var m = modBits$4(n);
  return lsl$4(i, m) | lsr$4(i, 32 - m | 0);
}

function rlsr$4(i, n) {
  var m = modBits$4(n);
  return lsr$4(i, m) | lsl$4(i, 32 - m | 0);
}

var clz$4 = is32Bits$4 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 0 | 0;
      } else {
        return c;
      }
    });

var imul$4 = is32Bits$4 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      var i = Math.imul(a, b);
      if ((i & highestBit$2) === 0) {
        return i & mask$4;
      } else {
        return i | maskNot$2;
      }
    });

var include$14 = ResNumber__Math.MakeIntegerMath({
      fromFloat: fromFloat$4,
      fromFloatExn: fromFloatExn$4,
      fromFloatClamped: fromFloatClamped$4,
      fromFloatUnsafe: fromFloatUnsafe$4,
      toFloat: toFloat$4,
      clz: clz$4,
      imul: imul$4
    });

function neg$2(i) {
  if (i !== Js_int.min) {
    return -i | 0;
  }
  
}

function negExn$2(i) {
  var v = neg$2(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(- i, {
                minValue: Js_int.min,
                maxValue: Js_int.max
              });
  }
}

function negUnsafe$2(i) {
  return -i | 0;
}

function abs$2(i) {
  if (i !== Js_int.min) {
    return Math.abs(i);
  }
  
}

function absExn$2(i) {
  var v = abs$2(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                minValue: Js_int.min,
                maxValue: Js_int.max
              });
  }
}

function absUnsafe$2(i) {
  return PervasivesU.abs(i);
}

function signExn$2(i) {
  var match = Math.sign(i);
  switch (match) {
    case -1 :
        return -1;
    case 0 :
        return 0;
    case 1 :
        return 1;
    default:
      return 0;
  }
}

function sign$2(i) {
  return signExn$2(i);
}

function signRaw$2(i) {
  return Math.sign(i);
}

var Int32_inc = include$12.inc;

var Int32_incExn = include$12.incExn;

var Int32_incUnsafe = include$12.incUnsafe;

var Int32_dec = include$12.dec;

var Int32_decExn = include$12.decExn;

var Int32_decUnsafe = include$12.decUnsafe;

var Int32_sum = include$13.sum;

var Int32_sumExn = include$13.sumExn;

var Int32_sumUnsafe = include$13.sumUnsafe;

var Int32_clz = include$14.clz;

var Int32_imul = include$14.imul;

var Int32_pow = include$14.pow;

var Int32_powExn = include$14.powExn;

var Int32_powUnsafe = include$14.powUnsafe;

var Int32_random = include$14.random;

var Int32 = {
  isSigned: true,
  isUnsigned: isUnsigned$4,
  bits: 32,
  fromInt: fromInt$4,
  fromIntExn: fromIntExn$4,
  fromIntClamped: fromIntClamped$4,
  fromIntUnsafe: fromIntUnsafe$4,
  toInt: toInt$4,
  toIntExn: toIntExn$4,
  toIntClamped: toIntClamped$4,
  toIntUnsafe: toIntUnsafe$4,
  fromFloat: fromFloat$4,
  fromFloatExn: fromFloatExn$4,
  fromFloatClamped: fromFloatClamped$4,
  fromFloatUnsafe: fromFloatUnsafe$4,
  toFloat: toFloat$4,
  fromString: fromString$4,
  fromStringExn: fromStringExn$4,
  toString: toString$4,
  zero: 0,
  one: 1,
  minValue: Js_int.min,
  maxValue: Js_int.max,
  compare: compare$4,
  compareExn: compareExn$4,
  eq: eq$4,
  ne: ne$4,
  lt: lt$4,
  le: le$4,
  gt: gt$4,
  ge: ge$4,
  min: min$4,
  minMany: minMany$4,
  minManyExn: minManyExn$4,
  minManyUnsafe: minManyUnsafe$4,
  max: max$4,
  maxMany: maxMany$4,
  maxManyExn: maxManyExn$4,
  maxManyUnsafe: maxManyUnsafe$4,
  add: add$4,
  addExn: addExn$4,
  addClamped: addClamped$4,
  addUnsafe: addUnsafe$4,
  sub: sub$4,
  subExn: subExn$4,
  subClamped: subClamped$4,
  subUnsafe: subUnsafe$4,
  mul: mul$4,
  mulExn: mulExn$4,
  mulClamped: mulClamped$4,
  mulUnsafe: mulUnsafe$4,
  div: div$4,
  divExn: divExn$4,
  divUnsafe: divUnsafe$4,
  rem: rem$4,
  remExn: remExn$4,
  remUnsafe: remUnsafe$4,
  inc: Int32_inc,
  incExn: Int32_incExn,
  incUnsafe: Int32_incUnsafe,
  dec: Int32_dec,
  decExn: Int32_decExn,
  decUnsafe: Int32_decUnsafe,
  sum: Int32_sum,
  sumExn: Int32_sumExn,
  sumUnsafe: Int32_sumUnsafe,
  lnot: lnot$4,
  land: land$4,
  lor: lor$4,
  lxor: lxor$4,
  lsl: lsl$4,
  lsr: lsr$4,
  asr: asr$4,
  rlsl: rlsl$4,
  rlsr: rlsr$4,
  clz: Int32_clz,
  imul: Int32_imul,
  pow: Int32_pow,
  powExn: Int32_powExn,
  powUnsafe: Int32_powUnsafe,
  random: Int32_random,
  neg: neg$2,
  negExn: negExn$2,
  negUnsafe: negUnsafe$2,
  abs: abs$2,
  absExn: absExn$2,
  absUnsafe: absUnsafe$2,
  sign: sign$2,
  signExn: signExn$2,
  signRaw: signRaw$2
};

var IntRange$5 = {
  minValue: 0.0,
  maxValue: 4294967295.0
};

function toString$5(i) {
  return i.toString();
}

if (0.0 < Number.MIN_SAFE_INTEGER || 4294967295.0 > Number.MAX_SAFE_INTEGER) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (0.0).toString() + ", maxValue: " + (4294967295.0).toString() + ", max range: " + Number.MIN_SAFE_INTEGER.toString() + " - " + Number.MAX_SAFE_INTEGER.toString());
}

function fromInt$5(i) {
  if (i >= 0.0 && i <= 4294967295.0) {
    return i;
  }
  
}

function fromIntExn$5(i) {
  if (i >= 0.0 && i <= 4294967295.0) {
    return i;
  } else {
    return ResNumber__Utils.raiseOverflow(i, IntRange$5);
  }
}

function fromIntClamped$5(i) {
  if (i < 0.0) {
    return 0.0;
  } else if (i > 4294967295.0) {
    return 4294967295.0;
  } else {
    return i;
  }
}

function toInt$5(i) {
  if (ResNumber__Utils.inInt32Range(i)) {
    return i;
  }
  
}

function toIntExn$5(i) {
  if (ResNumber__Utils.inInt32Range(i)) {
    return i;
  } else {
    return ResNumber__Utils.raiseOverflow(i, ResNumber__Utils.Int32Range);
  }
}

function toIntClamped$5(i) {
  if (i < Js_int.min) {
    return Js_int.min;
  } else if (i > Js_int.max) {
    return Js_int.max;
  } else {
    return i;
  }
}

function toIntUnsafe$5(i) {
  return i | 0;
}

function fromFloat$5(f) {
  if (Number.isInteger(f) && f >= 0.0 && f <= 4294967295.0) {
    return f;
  }
  
}

function fromFloatExn$5(f) {
  if (Number.isInteger(f)) {
    if (f < 0.0 || f > 4294967295.0) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$5);
    } else {
      return f;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not a integer");
  }
}

function fromFloatClamped$5(f) {
  if (f < 0.0) {
    return 0.0;
  } else if (f > 4294967295.0) {
    return 4294967295.0;
  } else {
    return Math.trunc(f);
  }
}

function toFloat$5(f) {
  return f;
}

function fromString$5(s) {
  var f = ResNumber__Utils.stringToFloat(s);
  if (f !== undefined) {
    return fromFloat$5(f);
  }
  
}

function fromStringExn$5(s) {
  var f = ResNumber__Utils.stringToFloat(s);
  if (f !== undefined) {
    return fromFloatExn$5(f);
  } else {
    return PervasivesU.invalid_arg("the string is not a integer: " + s);
  }
}

function compareExn$5(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$5(a, b) {
  return compareExn$5(a, b);
}

function eq$5(a, b) {
  return a === b;
}

function ne$5(a, b) {
  return a !== b;
}

function lt$5(a, b) {
  return a < b;
}

function le$5(a, b) {
  return a <= b;
}

function gt$5(a, b) {
  return a > b;
}

function ge$5(a, b) {
  return a >= b;
}

function min$5(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$5(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$5(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function minManyUnsafe$5(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]);
}

function max$5(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$5(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$5(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray(undefined);
  }
}

function maxManyUnsafe$5(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]);
}

function fromFloatUncheckInteger$5(f) {
  if (f >= 0.0 && f <= 4294967295.0) {
    return f;
  }
  
}

function fromFloatUncheckIntegerExn$5(f) {
  if (f >= 0.0 && f <= 4294967295.0) {
    return f;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$5);
  }
}

function fromFloatUncheckIntegerClamped$5(f) {
  if (f < 0.0) {
    return 0.0;
  } else if (f > 4294967295.0) {
    return 4294967295.0;
  } else {
    return f;
  }
}

function addUnsafe$5(a, b) {
  return a + b;
}

function add$5(a, b) {
  return fromFloatUncheckInteger$5(a + b);
}

function addExn$5(a, b) {
  return fromFloatUncheckIntegerExn$5(a + b);
}

function addClamped$5(a, b) {
  return fromFloatUncheckIntegerClamped$5(a + b);
}

function subUnsafe$5(a, b) {
  return a - b;
}

function sub$5(a, b) {
  return fromFloatUncheckInteger$5(a - b);
}

function subExn$5(a, b) {
  return fromFloatUncheckIntegerExn$5(a - b);
}

function subClamped$5(a, b) {
  return fromFloatUncheckIntegerClamped$5(a - b);
}

function mulUnsafe$5(a, b) {
  return a * b;
}

function mul$5(a, b) {
  return fromFloatUncheckInteger$5(a * b);
}

function mulExn$5(a, b) {
  return fromFloatUncheckIntegerExn$5(a * b);
}

function mulClamped$5(a, b) {
  return fromFloatUncheckIntegerClamped$5(a * b);
}

function divUnsafe$5(a, b) {
  return Math.trunc(a / b);
}

function div$5(a, b) {
  if (b !== 0.0) {
    return divUnsafe$5(a, b);
  }
  
}

function divExn$5(a, b) {
  if (b !== 0.0) {
    return divUnsafe$5(a, b);
  }
  throw {
        RE_EXN_ID: "Division_by_zero",
        Error: new Error()
      };
}

function remUnsafe$5(a, b) {
  return a % b;
}

function rem$5(a, b) {
  if (b !== 0.0) {
    return a % b;
  }
  
}

function remExn$5(a, b) {
  if (b !== 0.0) {
    return a % b;
  }
  throw {
        RE_EXN_ID: "Division_by_zero",
        Error: new Error()
      };
}

var include$15 = ResNumber__Operation.MakeNumberIncDec({
      one: 1.0,
      add: add$5,
      addExn: addExn$5,
      addClamped: addClamped$5,
      addUnsafe: addUnsafe$5,
      sub: sub$5,
      subExn: subExn$5,
      subClamped: subClamped$5,
      subUnsafe: subUnsafe$5
    });

var include$16 = ResNumber__Operation.MakeNumberSum({
      add: add$5,
      addExn: addExn$5,
      addClamped: addClamped$5,
      addUnsafe: addUnsafe$5
    });

function fromIntUnsafe$5(i) {
  return toUint32(i);
}

function fromFloatUnsafe$5(f) {
  return toUint32(f);
}

function lnot$5(i) {
  return toUint32(PervasivesU.lnot(i));
}

function land$5(a, b) {
  return toUint32(a & b);
}

function lor$5(a, b) {
  return toUint32(a | b);
}

function lxor$5(a, b) {
  return toUint32(a ^ b);
}

function lsl$5(i, n) {
  return toUint32((i << n));
}

function lsr$5(i, n) {
  return (i >>> n);
}

function modBits$5(n) {
  if (n < 0 || n >= 32) {
    return toUint32(n) % 32;
  } else {
    return n;
  }
}

function rlsl$5(i, n) {
  var m = modBits$5(n);
  return toUint32((i << m) | (i >>> (32 - m | 0)) | 0);
}

function rlsr$5(i, n) {
  var m = modBits$5(n);
  return toUint32((i >>> m) | 0 | (i << (32 - m | 0)));
}

function clz$5(i) {
  return Math.clz32(i);
}

function imul$5(a, b) {
  return toUint32(Math.imul(a, b));
}

var include$17 = ResNumber__Math.MakeIntegerMath({
      fromFloat: fromFloat$5,
      fromFloatExn: fromFloatExn$5,
      fromFloatClamped: fromFloatClamped$5,
      fromFloatUnsafe: fromFloatUnsafe$5,
      toFloat: toFloat$5,
      clz: clz$5,
      imul: imul$5
    });

var Uint32_inc = include$15.inc;

var Uint32_incExn = include$15.incExn;

var Uint32_incUnsafe = include$15.incUnsafe;

var Uint32_dec = include$15.dec;

var Uint32_decExn = include$15.decExn;

var Uint32_decUnsafe = include$15.decUnsafe;

var Uint32_sum = include$16.sum;

var Uint32_sumExn = include$16.sumExn;

var Uint32_sumUnsafe = include$16.sumUnsafe;

var Uint32_clz = include$17.clz;

var Uint32_imul = include$17.imul;

var Uint32_pow = include$17.pow;

var Uint32_powExn = include$17.powExn;

var Uint32_powUnsafe = include$17.powUnsafe;

var Uint32_random = include$17.random;

var Uint32 = {
  isSigned: false,
  isUnsigned: true,
  bits: 32,
  fromInt: fromInt$5,
  fromIntExn: fromIntExn$5,
  fromIntClamped: fromIntClamped$5,
  fromIntUnsafe: fromIntUnsafe$5,
  toInt: toInt$5,
  toIntExn: toIntExn$5,
  toIntClamped: toIntClamped$5,
  toIntUnsafe: toIntUnsafe$5,
  fromFloat: fromFloat$5,
  fromFloatExn: fromFloatExn$5,
  fromFloatClamped: fromFloatClamped$5,
  fromFloatUnsafe: fromFloatUnsafe$5,
  toFloat: toFloat$5,
  fromString: fromString$5,
  fromStringExn: fromStringExn$5,
  toString: toString$5,
  zero: 0.0,
  one: 1.0,
  minValue: 0.0,
  maxValue: 4294967295.0,
  compare: compare$5,
  compareExn: compareExn$5,
  eq: eq$5,
  ne: ne$5,
  lt: lt$5,
  le: le$5,
  gt: gt$5,
  ge: ge$5,
  min: min$5,
  minMany: minMany$5,
  minManyExn: minManyExn$5,
  minManyUnsafe: minManyUnsafe$5,
  max: max$5,
  maxMany: maxMany$5,
  maxManyExn: maxManyExn$5,
  maxManyUnsafe: maxManyUnsafe$5,
  add: add$5,
  addExn: addExn$5,
  addClamped: addClamped$5,
  addUnsafe: addUnsafe$5,
  sub: sub$5,
  subExn: subExn$5,
  subClamped: subClamped$5,
  subUnsafe: subUnsafe$5,
  mul: mul$5,
  mulExn: mulExn$5,
  mulClamped: mulClamped$5,
  mulUnsafe: mulUnsafe$5,
  div: div$5,
  divExn: divExn$5,
  divUnsafe: divUnsafe$5,
  rem: rem$5,
  remExn: remExn$5,
  remUnsafe: remUnsafe$5,
  inc: Uint32_inc,
  incExn: Uint32_incExn,
  incUnsafe: Uint32_incUnsafe,
  dec: Uint32_dec,
  decExn: Uint32_decExn,
  decUnsafe: Uint32_decUnsafe,
  sum: Uint32_sum,
  sumExn: Uint32_sumExn,
  sumUnsafe: Uint32_sumUnsafe,
  lnot: lnot$5,
  land: land$5,
  lor: lor$5,
  lxor: lxor$5,
  lsl: lsl$5,
  lsr: lsr$5,
  asr: lsr$5,
  rlsl: rlsl$5,
  rlsr: rlsr$5,
  clz: Uint32_clz,
  imul: Uint32_imul,
  pow: Uint32_pow,
  powExn: Uint32_powExn,
  powUnsafe: Uint32_powUnsafe,
  random: Uint32_random
};

export {
  toInt32 ,
  toUint32 ,
  MakeIntegerConversion ,
  MakeInteger ,
  MakeFixedBitsIntegerConversion ,
  MakeFixedBitsInt ,
  MakeFixedBitsInteger ,
  MakeSignedInteger ,
  MakeUnsignedInteger ,
  Int8 ,
  Uint8 ,
  Int16 ,
  Uint16 ,
  Int32 ,
  Uint32 ,
}
/*  Not a pure module */
