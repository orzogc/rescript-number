// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_int from "rescript/lib/es6/js_int.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";
import * as ResNumber__Utils from "./ResNumber__Utils.res.mjs";
import * as ResNumber__Operation from "./ResNumber__Operation.res.mjs";

function toUint32(i) {
  return (i >>> 0);
}

function MakeIntegerConversion(IntModule) {
  var minValue = IntModule.minValue;
  var maxValue = IntModule.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Number.MIN_SAFE_INTEGER || maxValue > Number.MAX_SAFE_INTEGER) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", range: " + Number.MIN_SAFE_INTEGER.toString() + " - " + Number.MAX_SAFE_INTEGER.toString());
  }
  var fromIntUnsafe = IntModule.fromIntUnsafe;
  var fromInt = function (i) {
    if (i >= minValue && i <= maxValue) {
      return fromIntUnsafe(i);
    }
    
  };
  var fromIntExn = function (i) {
    if (i >= minValue && i <= maxValue) {
      return fromIntUnsafe(i);
    } else {
      return ResNumber__Utils.raiseOverflow(i, IntModule);
    }
  };
  var fromIntClamped = function (i) {
    if (i < minValue) {
      return minValue;
    } else if (i > maxValue) {
      return maxValue;
    } else {
      return fromIntUnsafe(i);
    }
  };
  var toInt = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    }
    
  };
  var toIntExn = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    } else {
      return ResNumber__Utils.raiseOverflow(i, ResNumber__Utils.Int32Range);
    }
  };
  var toIntClamped = function (i) {
    if (i < Js_int.min) {
      return Js_int.min;
    } else if (i > Js_int.max) {
      return Js_int.max;
    } else {
      return i;
    }
  };
  var toIntUnsafe = function (i) {
    return i | 0;
  };
  var fromFloatUnsafe = IntModule.fromFloatUnsafe;
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return fromFloatUnsafe(f);
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntModule);
      } else {
        return fromFloatUnsafe(f);
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return fromFloatUnsafe(f);
    }
  };
  var toFloat = function (f) {
    return f;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn
        };
}

function MakeNumberIncDec(M) {
  var inc = function (n) {
    return M.add(n, M.one);
  };
  var incExn = function (n) {
    return M.addExn(n, M.one);
  };
  var incUnsafe = function (n) {
    return M.addUnsafe(n, M.one);
  };
  var dec = function (n) {
    return M.sub(n, M.one);
  };
  var decExn = function (n) {
    return M.subExn(n, M.one);
  };
  var decUnsafe = function (n) {
    return M.subUnsafe(n, M.one);
  };
  return {
          inc: inc,
          incExn: incExn,
          incUnsafe: incUnsafe,
          dec: dec,
          decExn: decExn,
          decUnsafe: decUnsafe
        };
}

function MakeInteger(IntModule) {
  var minValue = IntModule.minValue;
  var maxValue = IntModule.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Number.MIN_SAFE_INTEGER || maxValue > Number.MAX_SAFE_INTEGER) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", range: " + Number.MIN_SAFE_INTEGER.toString() + " - " + Number.MAX_SAFE_INTEGER.toString());
  }
  var fromIntUnsafe = IntModule.fromIntUnsafe;
  var fromInt = function (i) {
    if (i >= minValue && i <= maxValue) {
      return fromIntUnsafe(i);
    }
    
  };
  var fromIntExn = function (i) {
    if (i >= minValue && i <= maxValue) {
      return fromIntUnsafe(i);
    } else {
      return ResNumber__Utils.raiseOverflow(i, IntModule);
    }
  };
  var fromIntClamped = function (i) {
    if (i < minValue) {
      return minValue;
    } else if (i > maxValue) {
      return maxValue;
    } else {
      return fromIntUnsafe(i);
    }
  };
  var toInt = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    }
    
  };
  var toIntExn = function (i) {
    if (ResNumber__Utils.inInt32Range(i)) {
      return i;
    } else {
      return ResNumber__Utils.raiseOverflow(i, ResNumber__Utils.Int32Range);
    }
  };
  var toIntClamped = function (i) {
    if (i < Js_int.min) {
      return Js_int.min;
    } else if (i > Js_int.max) {
      return Js_int.max;
    } else {
      return i;
    }
  };
  var toIntUnsafe = function (i) {
    return i | 0;
  };
  var fromFloatUnsafe = IntModule.fromFloatUnsafe;
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return fromFloatUnsafe(f);
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntModule);
      } else {
        return fromFloatUnsafe(f);
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return fromFloatUnsafe(f);
    }
  };
  var toFloat = function (f) {
    return f;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  var minValue$1 = IntModule.minValue;
  var maxValue$1 = IntModule.maxValue;
  if (minValue$1 > 0.0 || maxValue$1 < 1.0) {
    PervasivesU.invalid_arg((0.0).toString() + " and " + (1.0).toString() + " must be between minValue " + minValue$1.toString() + " and maxValue " + maxValue$1.toString());
  }
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return fromFloatUnsafe(f);
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return fromFloatUnsafe(f);
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntModule);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue$1) {
      return minValue$1;
    } else if (f > maxValue$1) {
      return maxValue$1;
    } else {
      return fromFloatUnsafe(f);
    }
  };
  var fromStringWithRadix = function (s, radix) {
    var f = parseInt(s, radix);
    if (!Number.isNaN(f)) {
      return fromFloatUncheckInteger(f);
    }
    
  };
  var fromStringWithRadixExn = function (s, radix) {
    var f = parseInt(s, radix);
    if (Number.isNaN(f)) {
      if (radix >= 2 && radix <= 36) {
        return PervasivesU.invalid_arg("the string is not an integer: " + s);
      } else {
        return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
      }
    } else {
      return fromFloatUncheckIntegerExn(f);
    }
  };
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var minManyUnsafe = function (arr) {
    return fromFloatUnsafe(Caml_splice_call.spliceApply(Math.min, [arr]));
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var maxManyUnsafe = function (arr) {
    return fromFloatUnsafe(Caml_splice_call.spliceApply(Math.max, [arr]));
  };
  var add = function (a, b) {
    return fromFloatUncheckInteger(a + b);
  };
  var addExn = function (a, b) {
    return fromFloatUncheckIntegerExn(a + b);
  };
  var addClamped = function (a, b) {
    return fromFloatUncheckIntegerClamped(a + b);
  };
  var addUnsafe = function (a, b) {
    return fromFloatUnsafe(a + b);
  };
  var sub = function (a, b) {
    return fromFloatUncheckInteger(a - b);
  };
  var subExn = function (a, b) {
    return fromFloatUncheckIntegerExn(a - b);
  };
  var subClamped = function (a, b) {
    return fromFloatUncheckIntegerClamped(a - b);
  };
  var subUnsafe = function (a, b) {
    return fromFloatUnsafe(a - b);
  };
  var mul = function (a, b) {
    return fromFloatUncheckInteger(a * b);
  };
  var mulExn = function (a, b) {
    return fromFloatUncheckIntegerExn(a * b);
  };
  var mulClamped = function (a, b) {
    return fromFloatUncheckIntegerClamped(a * b);
  };
  var mulUnsafe = function (a, b) {
    return fromFloatUnsafe(a * b);
  };
  var divUnsafe = function (a, b) {
    return fromFloatUnsafe(a / b);
  };
  var div = function (a, b) {
    if (b !== 0.0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = function (a, b) {
    if (b !== 0.0) {
      return divUnsafe(a, b);
    }
    throw {
          RE_EXN_ID: "Division_by_zero",
          Error: new Error()
        };
  };
  var remUnsafe = function (a, b) {
    return fromFloatUnsafe(a % b);
  };
  var rem = function (a, b) {
    if (b !== 0.0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = function (a, b) {
    if (b !== 0.0) {
      return remUnsafe(a, b);
    }
    throw {
          RE_EXN_ID: "Division_by_zero",
          Error: new Error()
        };
  };
  var include = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  var inc = function (n) {
    return add(n, 1.0);
  };
  var incExn = function (n) {
    return addExn(n, 1.0);
  };
  var incUnsafe = function (n) {
    return addUnsafe(n, 1.0);
  };
  var dec = function (n) {
    return sub(n, 1.0);
  };
  var decExn = function (n) {
    return subExn(n, 1.0);
  };
  var decUnsafe = function (n) {
    return subUnsafe(n, 1.0);
  };
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn,
          fromStringWithRadix: fromStringWithRadix,
          fromStringWithRadixExn: fromStringWithRadixExn,
          zero: 0.0,
          one: 1.0,
          minValue: minValue$1,
          maxValue: maxValue$1,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          sum: include.sum,
          sumExn: include.sumExn,
          sumUnsafe: include.sumUnsafe,
          inc: inc,
          incExn: incExn,
          incUnsafe: incUnsafe,
          dec: dec,
          decExn: decExn,
          decUnsafe: decUnsafe
        };
}

function MakeFixedBitsIntegerConversion(IntRange) {
  var minValue = IntRange.minValue;
  var maxValue = IntRange.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromIntUnsafe = function (i) {
    return i | 0;
  };
  var fromInt = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i | 0;
        }
      });
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f | 0;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn
        };
}

function MakeFixedBitsInt(IntRange) {
  var minValue = IntRange.minValue;
  var maxValue = IntRange.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromIntUnsafe = function (i) {
    return i | 0;
  };
  var fromInt = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i | 0;
        }
      });
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f | 0;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  var minValue$1 = IntRange.minValue;
  var maxValue$1 = IntRange.maxValue;
  if (minValue$1 > 0 || maxValue$1 < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue$1.toString() + " and maxValue " + maxValue$1.toString());
  }
  var fromStringWithRadix = function (s, radix) {
    var f = parseInt(s, radix);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringWithRadixExn = function (s, radix) {
    var f = parseInt(s, radix);
    if (Number.isNaN(f)) {
      if (radix >= 2 && radix <= 36) {
        return PervasivesU.invalid_arg("the string is not an integer: " + s);
      } else {
        return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
      }
    } else {
      return fromFloatExn(f);
    }
  };
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f | 0;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f | 0;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue$1) {
      return minValue$1;
    } else if (f > maxValue$1) {
      return maxValue$1;
    } else {
      return f | 0;
    }
  };
  var isAddMaybeOverflow = minValue$1 + minValue$1 < Js_int.min || maxValue$1 + maxValue$1 > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue$1 - maxValue$1 < Js_int.min || maxValue$1 - minValue$1 > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue$1 * maxValue$1 < Js_int.min || minValue$1 * minValue$1 > Js_int.max || maxValue$1 * maxValue$1 > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = function (a, b) {
    return Caml_int32.mod_(a, b) | 0;
  };
  var include = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  var inc = function (n) {
    return add(n, 1);
  };
  var incExn = function (n) {
    return addExn(n, 1);
  };
  var incUnsafe = function (n) {
    return n + 1 | 0;
  };
  var dec = function (n) {
    return sub(n, 1);
  };
  var decExn = function (n) {
    return subExn(n, 1);
  };
  var decUnsafe = function (n) {
    return n - 1 | 0;
  };
  return {
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn,
          fromStringWithRadix: fromStringWithRadix,
          fromStringWithRadixExn: fromStringWithRadixExn,
          zero: 0,
          one: 1,
          minValue: minValue$1,
          maxValue: maxValue$1,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          sum: include.sum,
          sumExn: include.sumExn,
          sumUnsafe: include.sumUnsafe,
          inc: inc,
          incExn: incExn,
          incUnsafe: incUnsafe,
          dec: dec,
          decExn: decExn,
          decUnsafe: decUnsafe
        };
}

function MakeIntegerMath(M) {
  var pow_ = function (base, exp) {
    return Math.pow(M.toFloat(base), M.toFloat(exp));
  };
  var pow = function (base, exp) {
    return M.fromFloat(pow_(base, exp));
  };
  var powExn = function (base, exp) {
    return M.fromFloatExn(pow_(base, exp));
  };
  var powUnsafe = function (base, exp) {
    return M.fromFloatUnsafe(pow_(base, exp));
  };
  var random = function (min, max) {
    var min_ = M.toFloat(min);
    var max_ = M.toFloat(max);
    return M.fromFloatClamped(Math.floor(Math.random() * (max_ - min_) + min_));
  };
  return {
          clz: M.clz,
          imul: M.imul,
          pow: pow,
          powExn: powExn,
          powUnsafe: powUnsafe,
          random: random
        };
}

function MakeFixedBitsInteger(M) {
  var IntRange_minValue = M.minValue;
  var IntRange_maxValue = M.maxValue;
  var IntRange = {
    minValue: IntRange_minValue,
    maxValue: IntRange_maxValue
  };
  var minValue = M.minValue;
  var maxValue = M.maxValue;
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromIntUnsafe = function (i) {
    return i | 0;
  };
  var fromInt = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i | 0;
        }
      });
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f | 0;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  var minValue$1 = M.minValue;
  var maxValue$1 = M.maxValue;
  if (minValue$1 > 0 || maxValue$1 < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue$1.toString() + " and maxValue " + maxValue$1.toString());
  }
  var fromStringWithRadix = function (s, radix) {
    var f = parseInt(s, radix);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringWithRadixExn = function (s, radix) {
    var f = parseInt(s, radix);
    if (Number.isNaN(f)) {
      if (radix >= 2 && radix <= 36) {
        return PervasivesU.invalid_arg("the string is not an integer: " + s);
      } else {
        return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
      }
    } else {
      return fromFloatExn(f);
    }
  };
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f | 0;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue$1 && f <= maxValue$1) {
      return f | 0;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue$1) {
      return minValue$1;
    } else if (f > maxValue$1) {
      return maxValue$1;
    } else {
      return f | 0;
    }
  };
  var isAddMaybeOverflow = minValue$1 + minValue$1 < Js_int.min || maxValue$1 + maxValue$1 > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue$1 - maxValue$1 < Js_int.min || maxValue$1 - minValue$1 > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue$1 * maxValue$1 < Js_int.min || minValue$1 * minValue$1 > Js_int.max || maxValue$1 * maxValue$1 > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = function (a, b) {
    return Caml_int32.mod_(a, b) | 0;
  };
  var include = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  var inc = function (n) {
    return add(n, 1);
  };
  var incExn = function (n) {
    return addExn(n, 1);
  };
  var incUnsafe = function (n) {
    return n + 1 | 0;
  };
  var dec = function (n) {
    return sub(n, 1);
  };
  var decExn = function (n) {
    return subExn(n, 1);
  };
  var decUnsafe = function (n) {
    return n - 1 | 0;
  };
  var bits = M.bits;
  if (bits <= 0 || bits > 32) {
    PervasivesU.invalid_arg("bits must not be less than 1 or greater than 32: " + bits.toString());
  }
  var isSigned = M.isSigned;
  var isUnsigned = !isSigned;
  if (isSigned) {
    if (minValue$1 >= 0) {
      PervasivesU.invalid_arg("minValue for signed integer must be less than 0: " + minValue$1.toString());
    }
    var n = Math.abs(minValue$1);
    if (Math.log2(n) !== (bits - 1 | 0)) {
      PervasivesU.invalid_arg("invalid minValue " + minValue$1.toString() + " for " + bits.toString() + " bits signed integer");
    }
    if (n - 1.0 !== maxValue$1) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue$1.toString() + " for " + bits.toString() + " bits signed integer");
    }
    
  }
  if (isUnsigned) {
    if (minValue$1 !== 0) {
      PervasivesU.invalid_arg("invalid minValue " + minValue$1.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    if (Math.pow(2.0, bits) - 1.0 !== maxValue$1) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue$1.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    
  }
  var is32Bits = bits === 32;
  var mask = (-1 >>> (32 - bits | 0)) | 0;
  var maskNot = PervasivesU.lnot(mask);
  var highestBit = (1 << (bits - 1 | 0));
  var lnot = isUnsigned ? (function (i) {
        return PervasivesU.lnot(i) & mask;
      }) : PervasivesU.lnot;
  var land = function (prim0, prim1) {
    return prim0 & prim1;
  };
  var lor = function (prim0, prim1) {
    return prim0 | prim1;
  };
  var lxor = function (prim0, prim1) {
    return prim0 ^ prim1;
  };
  var modBits = function (n) {
    if (n < 0 || n >= bits) {
      return toUint32(n) % bits;
    } else {
      return n;
    }
  };
  var lsl = is32Bits ? (function (prim0, prim1) {
        return (prim0 << prim1);
      }) : (
      isSigned ? (function (i, n) {
            var m = modBits(n);
            if (m === 0) {
              return i;
            }
            var v = (i << m);
            if ((v & highestBit) === 0) {
              return v & mask;
            } else {
              return v | maskNot;
            }
          }) : (function (i, n) {
            var m = modBits(n);
            if (m !== 0) {
              return (i << m) & mask;
            } else {
              return i;
            }
          })
    );
  var lsr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >>> prim1) | 0;
      }) : (
      isSigned ? (function (i, n) {
            var m = modBits(n);
            if (m !== 0) {
              return ((i & mask) >>> m) | 0;
            } else {
              return i;
            }
          }) : (function (i, n) {
            return (i >>> modBits(n)) | 0;
          })
    );
  var asr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >> prim1);
      }) : (function (i, n) {
        return (i >> modBits(n));
      });
  var rsl = function (i, n) {
    var m = modBits(n);
    if (m !== 0) {
      return lsl(i, m) | lsr(i, bits - m | 0);
    } else {
      return i;
    }
  };
  var rsr = function (i, n) {
    var m = modBits(n);
    if (m !== 0) {
      return lsr(i, m) | lsl(i, bits - m | 0);
    } else {
      return i;
    }
  };
  var clz = is32Bits ? (function (i) {
        return Math.clz32(i);
      }) : (function (i) {
        var c = Math.clz32(i);
        if (c > 0) {
          return c - (32 - bits | 0) | 0;
        } else {
          return c;
        }
      });
  var imul = is32Bits ? (function (a, b) {
        return Math.imul(a, b);
      }) : (
      isSigned ? (function (a, b) {
            var i = Math.imul(a, b);
            if ((i & highestBit) === 0) {
              return i & mask;
            } else {
              return i | maskNot;
            }
          }) : (function (a, b) {
            return Math.imul(a, b) & mask;
          })
    );
  var pow_ = function (base, exp) {
    return Math.pow(base, exp);
  };
  var pow = function (base, exp) {
    return fromFloat(pow_(base, exp));
  };
  var powExn = function (base, exp) {
    return fromFloatExn(pow_(base, exp));
  };
  var powUnsafe = function (base, exp) {
    return pow_(base, exp) | 0;
  };
  var random = function (min, max) {
    var min_ = min;
    var max_ = max;
    return fromFloatClamped(Math.floor(Math.random() * (max_ - min_) + min_));
  };
  return {
          isSigned: isSigned,
          isUnsigned: isUnsigned,
          bits: bits,
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn,
          fromStringWithRadix: fromStringWithRadix,
          fromStringWithRadixExn: fromStringWithRadixExn,
          zero: 0,
          one: 1,
          minValue: minValue$1,
          maxValue: maxValue$1,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          sum: include.sum,
          sumExn: include.sumExn,
          sumUnsafe: include.sumUnsafe,
          inc: inc,
          incExn: incExn,
          incUnsafe: incUnsafe,
          dec: dec,
          decExn: decExn,
          decUnsafe: decUnsafe,
          lnot: lnot,
          land: land,
          lor: lor,
          lxor: lxor,
          lsl: lsl,
          lsr: lsr,
          asr: asr,
          rsl: rsl,
          rsr: rsr,
          clz: clz,
          imul: imul,
          pow: pow,
          powExn: powExn,
          powUnsafe: powUnsafe,
          random: random
        };
}

function MakeSignedInteger(M) {
  var bits = M.bits;
  var minValue = M.minValue;
  var maxValue = M.maxValue;
  var IntRange = {
    minValue: minValue,
    maxValue: maxValue
  };
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromIntUnsafe = function (i) {
    return i | 0;
  };
  var fromInt = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i | 0;
        }
      });
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f | 0;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  if (minValue > 0 || maxValue < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue.toString() + " and maxValue " + maxValue.toString());
  }
  var fromStringWithRadix = function (s, radix) {
    var f = parseInt(s, radix);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringWithRadixExn = function (s, radix) {
    var f = parseInt(s, radix);
    if (Number.isNaN(f)) {
      if (radix >= 2 && radix <= 36) {
        return PervasivesU.invalid_arg("the string is not an integer: " + s);
      } else {
        return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
      }
    } else {
      return fromFloatExn(f);
    }
  };
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f | 0;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var isAddMaybeOverflow = minValue + minValue < Js_int.min || maxValue + maxValue > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue - maxValue < Js_int.min || maxValue - minValue > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue * maxValue < Js_int.min || minValue * minValue > Js_int.max || maxValue * maxValue > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = function (a, b) {
    return Caml_int32.mod_(a, b) | 0;
  };
  var include = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  var inc = function (n) {
    return add(n, 1);
  };
  var incExn = function (n) {
    return addExn(n, 1);
  };
  var incUnsafe = function (n) {
    return n + 1 | 0;
  };
  var dec = function (n) {
    return sub(n, 1);
  };
  var decExn = function (n) {
    return subExn(n, 1);
  };
  var decUnsafe = function (n) {
    return n - 1 | 0;
  };
  if (bits <= 0 || bits > 32) {
    PervasivesU.invalid_arg("bits must not be less than 1 or greater than 32: " + bits.toString());
  }
  var isUnsigned = false;
  if (minValue >= 0) {
    PervasivesU.invalid_arg("minValue for signed integer must be less than 0: " + minValue.toString());
  }
  var n = Math.abs(minValue);
  if (Math.log2(n) !== (bits - 1 | 0)) {
    PervasivesU.invalid_arg("invalid minValue " + minValue.toString() + " for " + bits.toString() + " bits signed integer");
  }
  if (n - 1.0 !== maxValue) {
    PervasivesU.invalid_arg("invalid maxValue " + maxValue.toString() + " for " + bits.toString() + " bits signed integer");
  }
  if (isUnsigned) {
    if (minValue !== 0) {
      PervasivesU.invalid_arg("invalid minValue " + minValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    if (Math.pow(2.0, bits) - 1.0 !== maxValue) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    
  }
  var is32Bits = bits === 32;
  var mask = (-1 >>> (32 - bits | 0)) | 0;
  var maskNot = PervasivesU.lnot(mask);
  var highestBit = (1 << (bits - 1 | 0));
  var lnot = isUnsigned ? (function (i) {
        return PervasivesU.lnot(i) & mask;
      }) : PervasivesU.lnot;
  var land = function (prim0, prim1) {
    return prim0 & prim1;
  };
  var lor = function (prim0, prim1) {
    return prim0 | prim1;
  };
  var lxor = function (prim0, prim1) {
    return prim0 ^ prim1;
  };
  var modBits = function (n) {
    if (n < 0 || n >= bits) {
      return toUint32(n) % bits;
    } else {
      return n;
    }
  };
  var lsl = is32Bits ? (function (prim0, prim1) {
        return (prim0 << prim1);
      }) : (function (i, n) {
        var m = modBits(n);
        if (m === 0) {
          return i;
        }
        var v = (i << m);
        if ((v & highestBit) === 0) {
          return v & mask;
        } else {
          return v | maskNot;
        }
      });
  var lsr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >>> prim1) | 0;
      }) : (function (i, n) {
        var m = modBits(n);
        if (m !== 0) {
          return ((i & mask) >>> m) | 0;
        } else {
          return i;
        }
      });
  var asr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >> prim1);
      }) : (function (i, n) {
        return (i >> modBits(n));
      });
  var rsl = function (i, n) {
    var m = modBits(n);
    if (m !== 0) {
      return lsl(i, m) | lsr(i, bits - m | 0);
    } else {
      return i;
    }
  };
  var rsr = function (i, n) {
    var m = modBits(n);
    if (m !== 0) {
      return lsr(i, m) | lsl(i, bits - m | 0);
    } else {
      return i;
    }
  };
  var clz = is32Bits ? (function (i) {
        return Math.clz32(i);
      }) : (function (i) {
        var c = Math.clz32(i);
        if (c > 0) {
          return c - (32 - bits | 0) | 0;
        } else {
          return c;
        }
      });
  var imul = is32Bits ? (function (a, b) {
        return Math.imul(a, b);
      }) : (function (a, b) {
        var i = Math.imul(a, b);
        if ((i & highestBit) === 0) {
          return i & mask;
        } else {
          return i | maskNot;
        }
      });
  var pow_ = function (base, exp) {
    return Math.pow(base, exp);
  };
  var pow = function (base, exp) {
    return fromFloat(pow_(base, exp));
  };
  var powExn = function (base, exp) {
    return fromFloatExn(pow_(base, exp));
  };
  var powUnsafe = function (base, exp) {
    return pow_(base, exp) | 0;
  };
  var random = function (min, max) {
    var min_ = min;
    var max_ = max;
    return fromFloatClamped(Math.floor(Math.random() * (max_ - min_) + min_));
  };
  var neg = function (i) {
    if (i !== minValue) {
      return -i | 0;
    }
    
  };
  var negExn = function (i) {
    var v = neg(i);
    if (v !== undefined) {
      return v;
    } else {
      return ResNumber__Utils.raiseOverflow(- i, {
                  minValue: M.minValue,
                  maxValue: M.maxValue
                });
    }
  };
  var negUnsafe = function (i) {
    return -i | 0;
  };
  var abs = function (i) {
    if (i !== minValue) {
      return Math.abs(i);
    }
    
  };
  var absExn = function (i) {
    var v = abs(i);
    if (v !== undefined) {
      return v;
    } else {
      return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                  minValue: M.minValue,
                  maxValue: M.maxValue
                });
    }
  };
  var absUnsafe = function (i) {
    return PervasivesU.abs(i);
  };
  var signExn = function (i) {
    var match = Math.sign(i);
    switch (match) {
      case -1 :
          return -1;
      case 0 :
          return 0;
      case 1 :
          return 1;
      default:
        return 0;
    }
  };
  var sign = function (i) {
    return signExn(i);
  };
  var signRaw = function (i) {
    return Math.sign(i);
  };
  return {
          isSigned: true,
          isUnsigned: isUnsigned,
          bits: bits,
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn,
          fromStringWithRadix: fromStringWithRadix,
          fromStringWithRadixExn: fromStringWithRadixExn,
          zero: 0,
          one: 1,
          minValue: minValue,
          maxValue: maxValue,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          sum: include.sum,
          sumExn: include.sumExn,
          sumUnsafe: include.sumUnsafe,
          inc: inc,
          incExn: incExn,
          incUnsafe: incUnsafe,
          dec: dec,
          decExn: decExn,
          decUnsafe: decUnsafe,
          lnot: lnot,
          land: land,
          lor: lor,
          lxor: lxor,
          lsl: lsl,
          lsr: lsr,
          asr: asr,
          rsl: rsl,
          rsr: rsr,
          clz: clz,
          imul: imul,
          pow: pow,
          powExn: powExn,
          powUnsafe: powUnsafe,
          random: random,
          neg: neg,
          negExn: negExn,
          negUnsafe: negUnsafe,
          abs: abs,
          absExn: absExn,
          absUnsafe: absUnsafe,
          sign: sign,
          signExn: signExn,
          signRaw: signRaw
        };
}

function MakeUnsignedInteger(M) {
  var bits = M.bits;
  var minValue = M.minValue;
  var maxValue = M.maxValue;
  var IntRange = {
    minValue: minValue,
    maxValue: maxValue
  };
  var toString = function (i) {
    return i.toString();
  };
  if (minValue > maxValue) {
    PervasivesU.invalid_arg("minValue " + minValue.toString() + " is greater than maxValue " + maxValue.toString());
  }
  if (minValue < Js_int.min || maxValue > Js_int.max) {
    PervasivesU.invalid_arg("the range of integer overflows, minValue: " + minValue.toString() + ", maxValue: " + maxValue.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
  }
  var isInt32 = minValue === Js_int.min && maxValue === Js_int.max;
  var fromIntUnsafe = function (i) {
    return i | 0;
  };
  var fromInt = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        }
        
      });
  var fromIntExn = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i >= minValue && i <= maxValue) {
          return i | 0;
        } else {
          return ResNumber__Utils.raiseOverflow(i, IntRange);
        }
      });
  var fromIntClamped = isInt32 ? (function (i) {
        return i | 0;
      }) : (function (i) {
        if (i < minValue) {
          return minValue;
        } else if (i > maxValue) {
          return maxValue;
        } else {
          return i | 0;
        }
      });
  var toInt = function (i) {
    return i;
  };
  var toIntExn = function (i) {
    return i;
  };
  var toIntClamped = function (i) {
    return i;
  };
  var toIntUnsafe = function (i) {
    return i;
  };
  var fromFloatUnsafe = function (f) {
    return f | 0;
  };
  var fromFloat = function (f) {
    if (Number.isInteger(f) && f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatExn = function (f) {
    if (Number.isInteger(f)) {
      if (f < minValue || f > maxValue) {
        return ResNumber__Utils.raiseOverflow(f, IntRange);
      } else {
        return f | 0;
      }
    } else {
      return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
    }
  };
  var fromFloatClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var toFloat = function (i) {
    return i;
  };
  var fromString = function (s) {
    var f = parseInt(s, undefined);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringExn = function (s) {
    var f = parseInt(s, undefined);
    if (Number.isNaN(f)) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return fromFloatExn(f);
    }
  };
  var toStringWithRadixExn = function (i, radix) {
    return i.toString(radix);
  };
  var toExponential = function (i) {
    return i.toExponential();
  };
  var toExponentialWithPrecisionExn = function (i, digits) {
    return i.toExponential(digits);
  };
  var toPrecision = function (i) {
    return i.toPrecision();
  };
  var toPrecisionWithPrecisionExn = function (i, digits) {
    return i.toPrecision(digits);
  };
  if (minValue > 0 || maxValue < 1) {
    PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + minValue.toString() + " and maxValue " + maxValue.toString());
  }
  var fromStringWithRadix = function (s, radix) {
    var f = parseInt(s, radix);
    if (!Number.isNaN(f)) {
      return fromFloat(f);
    }
    
  };
  var fromStringWithRadixExn = function (s, radix) {
    var f = parseInt(s, radix);
    if (Number.isNaN(f)) {
      if (radix >= 2 && radix <= 36) {
        return PervasivesU.invalid_arg("the string is not an integer: " + s);
      } else {
        return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
      }
    } else {
      return fromFloatExn(f);
    }
  };
  var compareExn = function (a, b) {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return 1;
    } else {
      return 0;
    }
  };
  var compare = function (a, b) {
    return compareExn(a, b);
  };
  var eq = function (a, b) {
    return a === b;
  };
  var ne = function (a, b) {
    return a !== b;
  };
  var lt = function (a, b) {
    return a < b;
  };
  var le = function (a, b) {
    return a <= b;
  };
  var gt = function (a, b) {
    return a > b;
  };
  var ge = function (a, b) {
    return a >= b;
  };
  var min = function (a, b) {
    if (a < b) {
      return a;
    } else {
      return b;
    }
  };
  var minMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
    }
    
  };
  var minManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.min, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var minManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
  };
  var max = function (a, b) {
    if (a > b) {
      return a;
    } else {
      return b;
    }
  };
  var maxMany = function (arr) {
    var len = arr.length;
    if (len > 0) {
      return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
    }
    
  };
  var maxManyExn = function (arr) {
    var len = arr.length;
    if (len > 0) {
      if (len === 1) {
        return arr[0];
      } else {
        return Caml_splice_call.spliceApply(Math.max, [arr]);
      }
    } else {
      return ResNumber__Utils.raiseEmptyArray();
    }
  };
  var maxManyUnsafe = function (arr) {
    return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
  };
  var fromFloatUncheckInteger = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f | 0;
    }
    
  };
  var fromFloatUncheckIntegerExn = function (f) {
    if (f >= minValue && f <= maxValue) {
      return f | 0;
    } else {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    }
  };
  var fromFloatUncheckIntegerClamped = function (f) {
    if (f < minValue) {
      return minValue;
    } else if (f > maxValue) {
      return maxValue;
    } else {
      return f | 0;
    }
  };
  var isAddMaybeOverflow = minValue + minValue < Js_int.min || maxValue + maxValue > Js_int.max;
  var addUnsafe = function (a, b) {
    return a + b | 0;
  };
  var add = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a + b);
      }) : (function (a, b) {
        return fromInt(a + b | 0);
      });
  var addExn = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a + b);
      }) : (function (a, b) {
        return fromIntExn(a + b | 0);
      });
  var addClamped = isAddMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a + b);
      }) : (function (a, b) {
        return fromIntClamped(a + b | 0);
      });
  var isSubMaybeOverflow = minValue - maxValue < Js_int.min || maxValue - minValue > Js_int.max;
  var subUnsafe = function (a, b) {
    return a - b | 0;
  };
  var sub = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a - b);
      }) : (function (a, b) {
        return fromInt(a - b | 0);
      });
  var subExn = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a - b);
      }) : (function (a, b) {
        return fromIntExn(a - b | 0);
      });
  var subClamped = isSubMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a - b);
      }) : (function (a, b) {
        return fromIntClamped(a - b | 0);
      });
  var isMulMaybeOverflow = minValue * maxValue < Js_int.min || minValue * minValue > Js_int.max || maxValue * maxValue > Js_int.max;
  var mulUnsafe = function (a, b) {
    return Math.imul(a, b);
  };
  var mul = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckInteger(a * b);
      }) : (function (a, b) {
        return fromInt(Math.imul(a, b));
      });
  var mulExn = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerExn(a * b);
      }) : (function (a, b) {
        return fromIntExn(Math.imul(a, b));
      });
  var mulClamped = isMulMaybeOverflow ? (function (a, b) {
        return fromFloatUncheckIntegerClamped(a * b);
      }) : (function (a, b) {
        return fromIntClamped(Math.imul(a, b));
      });
  var divUnsafe = function (a, b) {
    return a / b | 0;
  };
  var div = function (a, b) {
    if (b !== 0) {
      return divUnsafe(a, b);
    }
    
  };
  var divExn = Caml_int32.div;
  var remUnsafe = function (a, b) {
    return a % b | 0;
  };
  var rem = function (a, b) {
    if (b !== 0) {
      return remUnsafe(a, b);
    }
    
  };
  var remExn = function (a, b) {
    return Caml_int32.mod_(a, b) | 0;
  };
  var include = ResNumber__Operation.MakeNumberSum({
        add: add,
        addExn: addExn,
        addClamped: addClamped,
        addUnsafe: addUnsafe
      });
  var inc = function (n) {
    return add(n, 1);
  };
  var incExn = function (n) {
    return addExn(n, 1);
  };
  var incUnsafe = function (n) {
    return n + 1 | 0;
  };
  var dec = function (n) {
    return sub(n, 1);
  };
  var decExn = function (n) {
    return subExn(n, 1);
  };
  var decUnsafe = function (n) {
    return n - 1 | 0;
  };
  if (bits <= 0 || bits > 32) {
    PervasivesU.invalid_arg("bits must not be less than 1 or greater than 32: " + bits.toString());
  }
  var isUnsigned = true;
  if (isUnsigned) {
    if (minValue !== 0) {
      PervasivesU.invalid_arg("invalid minValue " + minValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    if (Math.pow(2.0, bits) - 1.0 !== maxValue) {
      PervasivesU.invalid_arg("invalid maxValue " + maxValue.toString() + " for " + bits.toString() + " bits unsigned integer");
    }
    
  }
  var is32Bits = bits === 32;
  var mask = (-1 >>> (32 - bits | 0)) | 0;
  PervasivesU.lnot(mask);
  var lnot = isUnsigned ? (function (i) {
        return PervasivesU.lnot(i) & mask;
      }) : PervasivesU.lnot;
  var land = function (prim0, prim1) {
    return prim0 & prim1;
  };
  var lor = function (prim0, prim1) {
    return prim0 | prim1;
  };
  var lxor = function (prim0, prim1) {
    return prim0 ^ prim1;
  };
  var modBits = function (n) {
    if (n < 0 || n >= bits) {
      return toUint32(n) % bits;
    } else {
      return n;
    }
  };
  var lsl = is32Bits ? (function (prim0, prim1) {
        return (prim0 << prim1);
      }) : (function (i, n) {
        var m = modBits(n);
        if (m !== 0) {
          return (i << m) & mask;
        } else {
          return i;
        }
      });
  var lsr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >>> prim1) | 0;
      }) : (function (i, n) {
        return (i >>> modBits(n)) | 0;
      });
  var asr = is32Bits ? (function (prim0, prim1) {
        return (prim0 >> prim1);
      }) : (function (i, n) {
        return (i >> modBits(n));
      });
  var rsl = function (i, n) {
    var m = modBits(n);
    if (m !== 0) {
      return lsl(i, m) | lsr(i, bits - m | 0);
    } else {
      return i;
    }
  };
  var rsr = function (i, n) {
    var m = modBits(n);
    if (m !== 0) {
      return lsr(i, m) | lsl(i, bits - m | 0);
    } else {
      return i;
    }
  };
  var clz = is32Bits ? (function (i) {
        return Math.clz32(i);
      }) : (function (i) {
        var c = Math.clz32(i);
        if (c > 0) {
          return c - (32 - bits | 0) | 0;
        } else {
          return c;
        }
      });
  var imul = is32Bits ? (function (a, b) {
        return Math.imul(a, b);
      }) : (function (a, b) {
        return Math.imul(a, b) & mask;
      });
  var pow_ = function (base, exp) {
    return Math.pow(base, exp);
  };
  var pow = function (base, exp) {
    return fromFloat(pow_(base, exp));
  };
  var powExn = function (base, exp) {
    return fromFloatExn(pow_(base, exp));
  };
  var powUnsafe = function (base, exp) {
    return pow_(base, exp) | 0;
  };
  var random = function (min, max) {
    var min_ = min;
    var max_ = max;
    return fromFloatClamped(Math.floor(Math.random() * (max_ - min_) + min_));
  };
  return {
          isSigned: false,
          isUnsigned: isUnsigned,
          bits: bits,
          fromInt: fromInt,
          fromIntExn: fromIntExn,
          fromIntClamped: fromIntClamped,
          fromIntUnsafe: fromIntUnsafe,
          toInt: toInt,
          toIntExn: toIntExn,
          toIntClamped: toIntClamped,
          toIntUnsafe: toIntUnsafe,
          fromFloat: fromFloat,
          fromFloatExn: fromFloatExn,
          fromFloatClamped: fromFloatClamped,
          fromFloatUnsafe: fromFloatUnsafe,
          toFloat: toFloat,
          fromString: fromString,
          fromStringExn: fromStringExn,
          toString: toString,
          toStringWithRadixExn: toStringWithRadixExn,
          toExponential: toExponential,
          toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
          toPrecision: toPrecision,
          toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn,
          fromStringWithRadix: fromStringWithRadix,
          fromStringWithRadixExn: fromStringWithRadixExn,
          zero: 0,
          one: 1,
          minValue: minValue,
          maxValue: maxValue,
          compare: compare,
          compareExn: compareExn,
          eq: eq,
          ne: ne,
          lt: lt,
          le: le,
          gt: gt,
          ge: ge,
          min: min,
          minMany: minMany,
          minManyExn: minManyExn,
          minManyUnsafe: minManyUnsafe,
          max: max,
          maxMany: maxMany,
          maxManyExn: maxManyExn,
          maxManyUnsafe: maxManyUnsafe,
          add: add,
          addExn: addExn,
          addClamped: addClamped,
          addUnsafe: addUnsafe,
          sub: sub,
          subExn: subExn,
          subClamped: subClamped,
          subUnsafe: subUnsafe,
          mul: mul,
          mulExn: mulExn,
          mulClamped: mulClamped,
          mulUnsafe: mulUnsafe,
          div: div,
          divExn: divExn,
          divUnsafe: divUnsafe,
          rem: rem,
          remExn: remExn,
          remUnsafe: remUnsafe,
          sum: include.sum,
          sumExn: include.sumExn,
          sumUnsafe: include.sumUnsafe,
          inc: inc,
          incExn: incExn,
          incUnsafe: incUnsafe,
          dec: dec,
          decExn: decExn,
          decUnsafe: decUnsafe,
          lnot: lnot,
          land: land,
          lor: lor,
          lxor: lxor,
          lsl: lsl,
          lsr: lsr,
          asr: asr,
          rsl: rsl,
          rsr: rsr,
          clz: clz,
          imul: imul,
          pow: pow,
          powExn: powExn,
          powUnsafe: powUnsafe,
          random: random
        };
}

var IntRange = {
  minValue: -128,
  maxValue: 127
};

function toString(i) {
  return i.toString();
}

if (-128 < Js_int.min || 127 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (-128).toString() + ", maxValue: " + (127).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32 = -128 === Js_int.min && 127 === Js_int.max;

function fromIntUnsafe(i) {
  return i | 0;
}

var fromInt = isInt32 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= -128 && i <= 127) {
        return i | 0;
      }
      
    });

var fromIntExn = isInt32 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= -128 && i <= 127) {
        return i | 0;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange);
      }
    });

var fromIntClamped = isInt32 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i < -128) {
        return -128;
      } else if (i > 127) {
        return 127;
      } else {
        return i | 0;
      }
    });

function toInt(i) {
  return i;
}

function toIntExn(i) {
  return i;
}

function toIntClamped(i) {
  return i;
}

function toIntUnsafe(i) {
  return i;
}

function fromFloatUnsafe(f) {
  return f | 0;
}

function fromFloat(f) {
  if (Number.isInteger(f) && f >= -128 && f <= 127) {
    return f | 0;
  }
  
}

function fromFloatExn(f) {
  if (Number.isInteger(f)) {
    if (f < -128 || f > 127) {
      return ResNumber__Utils.raiseOverflow(f, IntRange);
    } else {
      return f | 0;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
  }
}

function fromFloatClamped(f) {
  if (f < -128) {
    return -128;
  } else if (f > 127) {
    return 127;
  } else {
    return f | 0;
  }
}

function toFloat(i) {
  return i;
}

function fromString(s) {
  var f = parseInt(s, undefined);
  if (!Number.isNaN(f)) {
    return fromFloat(f);
  }
  
}

function fromStringExn(s) {
  var f = parseInt(s, undefined);
  if (Number.isNaN(f)) {
    return PervasivesU.invalid_arg("the string is not an integer: " + s);
  } else {
    return fromFloatExn(f);
  }
}

function toStringWithRadixExn(i, radix) {
  return i.toString(radix);
}

function toExponential(i) {
  return i.toExponential();
}

function toExponentialWithPrecisionExn(i, digits) {
  return i.toExponential(digits);
}

function toPrecision(i) {
  return i.toPrecision();
}

function toPrecisionWithPrecisionExn(i, digits) {
  return i.toPrecision(digits);
}

function fromStringWithRadix(s, radix) {
  var f = parseInt(s, radix);
  if (!Number.isNaN(f)) {
    return fromFloat(f);
  }
  
}

function fromStringWithRadixExn(s, radix) {
  var f = parseInt(s, radix);
  if (Number.isNaN(f)) {
    if (radix >= 2 && radix <= 36) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
    }
  } else {
    return fromFloatExn(f);
  }
}

function compareExn(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare(a, b) {
  return compareExn(a, b);
}

function eq(a, b) {
  return a === b;
}

function ne(a, b) {
  return a !== b;
}

function lt(a, b) {
  return a < b;
}

function le(a, b) {
  return a <= b;
}

function gt(a, b) {
  return a > b;
}

function ge(a, b) {
  return a >= b;
}

function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function minManyUnsafe(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
}

function max(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function maxManyUnsafe(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
}

function fromFloatUncheckInteger(f) {
  if (f >= -128 && f <= 127) {
    return f | 0;
  }
  
}

function fromFloatUncheckIntegerExn(f) {
  if (f >= -128 && f <= 127) {
    return f | 0;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange);
  }
}

function fromFloatUncheckIntegerClamped(f) {
  if (f < -128) {
    return -128;
  } else if (f > 127) {
    return 127;
  } else {
    return f | 0;
  }
}

var isAddMaybeOverflow = -256 < Js_int.min || 254 > Js_int.max;

function addUnsafe(a, b) {
  return a + b | 0;
}

var add = isAddMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckInteger(a + b);
    }) : (function (a, b) {
      return fromInt(a + b | 0);
    });

var addExn = isAddMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerExn(a + b);
    }) : (function (a, b) {
      return fromIntExn(a + b | 0);
    });

var addClamped = isAddMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerClamped(a + b);
    }) : (function (a, b) {
      return fromIntClamped(a + b | 0);
    });

var isSubMaybeOverflow = -255 < Js_int.min || 255 > Js_int.max;

function subUnsafe(a, b) {
  return a - b | 0;
}

var sub = isSubMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckInteger(a - b);
    }) : (function (a, b) {
      return fromInt(a - b | 0);
    });

var subExn = isSubMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerExn(a - b);
    }) : (function (a, b) {
      return fromIntExn(a - b | 0);
    });

var subClamped = isSubMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerClamped(a - b);
    }) : (function (a, b) {
      return fromIntClamped(a - b | 0);
    });

var isMulMaybeOverflow = -128 * 127 < Js_int.min || -128 * -128 > Js_int.max || 127 * 127 > Js_int.max;

function mulUnsafe(a, b) {
  return Math.imul(a, b);
}

var mul = isMulMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckInteger(a * b);
    }) : (function (a, b) {
      return fromInt(Math.imul(a, b));
    });

var mulExn = isMulMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerExn(a * b);
    }) : (function (a, b) {
      return fromIntExn(Math.imul(a, b));
    });

var mulClamped = isMulMaybeOverflow ? (function (a, b) {
      return fromFloatUncheckIntegerClamped(a * b);
    }) : (function (a, b) {
      return fromIntClamped(Math.imul(a, b));
    });

function divUnsafe(a, b) {
  return a / b | 0;
}

function div(a, b) {
  if (b !== 0) {
    return divUnsafe(a, b);
  }
  
}

var divExn = Caml_int32.div;

function remUnsafe(a, b) {
  return a % b | 0;
}

function rem(a, b) {
  if (b !== 0) {
    return remUnsafe(a, b);
  }
  
}

function remExn(a, b) {
  return Caml_int32.mod_(a, b) | 0;
}

var include = ResNumber__Operation.MakeNumberSum({
      add: add,
      addExn: addExn,
      addClamped: addClamped,
      addUnsafe: addUnsafe
    });

function inc(n) {
  return add(n, 1);
}

function incExn(n) {
  return addExn(n, 1);
}

function incUnsafe(n) {
  return n + 1 | 0;
}

function dec(n) {
  return sub(n, 1);
}

function decExn(n) {
  return subExn(n, 1);
}

function decUnsafe(n) {
  return n - 1 | 0;
}

var isUnsigned = false;

var n = Math.abs(-128);

if (Math.log2(n) !== 7) {
  PervasivesU.invalid_arg("invalid minValue " + (-128).toString() + " for " + (8).toString() + " bits signed integer");
}

if (n - 1.0 !== 127) {
  PervasivesU.invalid_arg("invalid maxValue " + (127).toString() + " for " + (8).toString() + " bits signed integer");
}

if (isUnsigned) {
  PervasivesU.invalid_arg("invalid minValue " + (-128).toString() + " for " + (8).toString() + " bits unsigned integer");
  if (Math.pow(2.0, 8) - 1.0 !== 127) {
    PervasivesU.invalid_arg("invalid maxValue " + (127).toString() + " for " + (8).toString() + " bits unsigned integer");
  }
  
}

var is32Bits = false;

var mask = 255;

var maskNot = PervasivesU.lnot(mask);

var highestBit = 128;

var lnot = isUnsigned ? (function (i) {
      return PervasivesU.lnot(i) & mask;
    }) : PervasivesU.lnot;

function land(prim0, prim1) {
  return prim0 & prim1;
}

function lor(prim0, prim1) {
  return prim0 | prim1;
}

function lxor(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits(n) {
  if (n < 0 || n >= 8) {
    return toUint32(n) % 8;
  } else {
    return n;
  }
}

var lsl = is32Bits ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var m = modBits(n);
      if (m === 0) {
        return i;
      }
      var v = (i << m);
      if ((v & highestBit) === 0) {
        return v & mask;
      } else {
        return v | maskNot;
      }
    });

var lsr = is32Bits ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      var m = modBits(n);
      if (m !== 0) {
        return ((i & mask) >>> m) | 0;
      } else {
        return i;
      }
    });

var asr = is32Bits ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits(n));
    });

function rsl(i, n) {
  var m = modBits(n);
  if (m !== 0) {
    return lsl(i, m) | lsr(i, 8 - m | 0);
  } else {
    return i;
  }
}

function rsr(i, n) {
  var m = modBits(n);
  if (m !== 0) {
    return lsr(i, m) | lsl(i, 8 - m | 0);
  } else {
    return i;
  }
}

var clz = is32Bits ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 24 | 0;
      } else {
        return c;
      }
    });

var imul = is32Bits ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      var i = Math.imul(a, b);
      if ((i & highestBit) === 0) {
        return i & mask;
      } else {
        return i | maskNot;
      }
    });

function pow_(base, exp) {
  return Math.pow(base, exp);
}

function pow(base, exp) {
  return fromFloat(pow_(base, exp));
}

function powExn(base, exp) {
  return fromFloatExn(pow_(base, exp));
}

function powUnsafe(base, exp) {
  return pow_(base, exp) | 0;
}

function random(min, max) {
  var min_ = min;
  var max_ = max;
  return fromFloatClamped(Math.floor(Math.random() * (max_ - min_) + min_));
}

function neg(i) {
  if (i !== -128) {
    return -i | 0;
  }
  
}

function negExn(i) {
  var v = neg(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(- i, {
                minValue: -128,
                maxValue: 127
              });
  }
}

function negUnsafe(i) {
  return -i | 0;
}

function abs(i) {
  if (i !== -128) {
    return Math.abs(i);
  }
  
}

function absExn(i) {
  var v = abs(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                minValue: -128,
                maxValue: 127
              });
  }
}

function absUnsafe(i) {
  return PervasivesU.abs(i);
}

function signExn(i) {
  var match = Math.sign(i);
  switch (match) {
    case -1 :
        return -1;
    case 0 :
        return 0;
    case 1 :
        return 1;
    default:
      return 0;
  }
}

function sign(i) {
  return signExn(i);
}

function signRaw(i) {
  return Math.sign(i);
}

var Int8_sum = include.sum;

var Int8_sumExn = include.sumExn;

var Int8_sumUnsafe = include.sumUnsafe;

var Int8 = {
  isSigned: true,
  isUnsigned: isUnsigned,
  bits: 8,
  fromInt: fromInt,
  fromIntExn: fromIntExn,
  fromIntClamped: fromIntClamped,
  fromIntUnsafe: fromIntUnsafe,
  toInt: toInt,
  toIntExn: toIntExn,
  toIntClamped: toIntClamped,
  toIntUnsafe: toIntUnsafe,
  fromFloat: fromFloat,
  fromFloatExn: fromFloatExn,
  fromFloatClamped: fromFloatClamped,
  fromFloatUnsafe: fromFloatUnsafe,
  toFloat: toFloat,
  fromString: fromString,
  fromStringExn: fromStringExn,
  toString: toString,
  toStringWithRadixExn: toStringWithRadixExn,
  toExponential: toExponential,
  toExponentialWithPrecisionExn: toExponentialWithPrecisionExn,
  toPrecision: toPrecision,
  toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn,
  fromStringWithRadix: fromStringWithRadix,
  fromStringWithRadixExn: fromStringWithRadixExn,
  zero: 0,
  one: 1,
  minValue: -128,
  maxValue: 127,
  compare: compare,
  compareExn: compareExn,
  eq: eq,
  ne: ne,
  lt: lt,
  le: le,
  gt: gt,
  ge: ge,
  min: min,
  minMany: minMany,
  minManyExn: minManyExn,
  minManyUnsafe: minManyUnsafe,
  max: max,
  maxMany: maxMany,
  maxManyExn: maxManyExn,
  maxManyUnsafe: maxManyUnsafe,
  add: add,
  addExn: addExn,
  addClamped: addClamped,
  addUnsafe: addUnsafe,
  sub: sub,
  subExn: subExn,
  subClamped: subClamped,
  subUnsafe: subUnsafe,
  mul: mul,
  mulExn: mulExn,
  mulClamped: mulClamped,
  mulUnsafe: mulUnsafe,
  div: div,
  divExn: divExn,
  divUnsafe: divUnsafe,
  rem: rem,
  remExn: remExn,
  remUnsafe: remUnsafe,
  sum: Int8_sum,
  sumExn: Int8_sumExn,
  sumUnsafe: Int8_sumUnsafe,
  inc: inc,
  incExn: incExn,
  incUnsafe: incUnsafe,
  dec: dec,
  decExn: decExn,
  decUnsafe: decUnsafe,
  lnot: lnot,
  land: land,
  lor: lor,
  lxor: lxor,
  lsl: lsl,
  lsr: lsr,
  asr: asr,
  rsl: rsl,
  rsr: rsr,
  clz: clz,
  imul: imul,
  pow: pow,
  powExn: powExn,
  powUnsafe: powUnsafe,
  random: random,
  neg: neg,
  negExn: negExn,
  negUnsafe: negUnsafe,
  abs: abs,
  absExn: absExn,
  absUnsafe: absUnsafe,
  sign: sign,
  signExn: signExn,
  signRaw: signRaw
};

var IntRange$1 = {
  minValue: 0,
  maxValue: 255
};

function toString$1(i) {
  return i.toString();
}

if (0 < Js_int.min || 255 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (0).toString() + ", maxValue: " + (255).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$1 = 0 === Js_int.min && 255 === Js_int.max;

function fromIntUnsafe$1(i) {
  return i | 0;
}

var fromInt$1 = isInt32$1 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= 0 && i <= 255) {
        return i | 0;
      }
      
    });

var fromIntExn$1 = isInt32$1 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= 0 && i <= 255) {
        return i | 0;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$1);
      }
    });

var fromIntClamped$1 = isInt32$1 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i < 0) {
        return 0;
      } else if (i > 255) {
        return 255;
      } else {
        return i | 0;
      }
    });

function toInt$1(i) {
  return i;
}

function toIntExn$1(i) {
  return i;
}

function toIntClamped$1(i) {
  return i;
}

function toIntUnsafe$1(i) {
  return i;
}

function fromFloatUnsafe$1(f) {
  return f | 0;
}

function fromFloat$1(f) {
  if (Number.isInteger(f) && f >= 0 && f <= 255) {
    return f | 0;
  }
  
}

function fromFloatExn$1(f) {
  if (Number.isInteger(f)) {
    if (f < 0 || f > 255) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$1);
    } else {
      return f | 0;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
  }
}

function fromFloatClamped$1(f) {
  if (f < 0) {
    return 0;
  } else if (f > 255) {
    return 255;
  } else {
    return f | 0;
  }
}

function toFloat$1(i) {
  return i;
}

function fromString$1(s) {
  var f = parseInt(s, undefined);
  if (!Number.isNaN(f)) {
    return fromFloat$1(f);
  }
  
}

function fromStringExn$1(s) {
  var f = parseInt(s, undefined);
  if (Number.isNaN(f)) {
    return PervasivesU.invalid_arg("the string is not an integer: " + s);
  } else {
    return fromFloatExn$1(f);
  }
}

function toStringWithRadixExn$1(i, radix) {
  return i.toString(radix);
}

function toExponential$1(i) {
  return i.toExponential();
}

function toExponentialWithPrecisionExn$1(i, digits) {
  return i.toExponential(digits);
}

function toPrecision$1(i) {
  return i.toPrecision();
}

function toPrecisionWithPrecisionExn$1(i, digits) {
  return i.toPrecision(digits);
}

function fromStringWithRadix$1(s, radix) {
  var f = parseInt(s, radix);
  if (!Number.isNaN(f)) {
    return fromFloat$1(f);
  }
  
}

function fromStringWithRadixExn$1(s, radix) {
  var f = parseInt(s, radix);
  if (Number.isNaN(f)) {
    if (radix >= 2 && radix <= 36) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
    }
  } else {
    return fromFloatExn$1(f);
  }
}

function compareExn$1(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$1(a, b) {
  return compareExn$1(a, b);
}

function eq$1(a, b) {
  return a === b;
}

function ne$1(a, b) {
  return a !== b;
}

function lt$1(a, b) {
  return a < b;
}

function le$1(a, b) {
  return a <= b;
}

function gt$1(a, b) {
  return a > b;
}

function ge$1(a, b) {
  return a >= b;
}

function min$1(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$1(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$1(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function minManyUnsafe$1(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
}

function max$1(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$1(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$1(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function maxManyUnsafe$1(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
}

function fromFloatUncheckInteger$1(f) {
  if (f >= 0 && f <= 255) {
    return f | 0;
  }
  
}

function fromFloatUncheckIntegerExn$1(f) {
  if (f >= 0 && f <= 255) {
    return f | 0;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$1);
  }
}

function fromFloatUncheckIntegerClamped$1(f) {
  if (f < 0) {
    return 0;
  } else if (f > 255) {
    return 255;
  } else {
    return f | 0;
  }
}

var isAddMaybeOverflow$1 = 0 < Js_int.min || 510 > Js_int.max;

function addUnsafe$1(a, b) {
  return a + b | 0;
}

var add$1 = isAddMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckInteger$1(a + b);
    }) : (function (a, b) {
      return fromInt$1(a + b | 0);
    });

var addExn$1 = isAddMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$1(a + b);
    }) : (function (a, b) {
      return fromIntExn$1(a + b | 0);
    });

var addClamped$1 = isAddMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$1(a + b);
    }) : (function (a, b) {
      return fromIntClamped$1(a + b | 0);
    });

var isSubMaybeOverflow$1 = -255 < Js_int.min || 255 > Js_int.max;

function subUnsafe$1(a, b) {
  return a - b | 0;
}

var sub$1 = isSubMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckInteger$1(a - b);
    }) : (function (a, b) {
      return fromInt$1(a - b | 0);
    });

var subExn$1 = isSubMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$1(a - b);
    }) : (function (a, b) {
      return fromIntExn$1(a - b | 0);
    });

var subClamped$1 = isSubMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$1(a - b);
    }) : (function (a, b) {
      return fromIntClamped$1(a - b | 0);
    });

var isMulMaybeOverflow$1 = 0 * 255 < Js_int.min || 0 * 0 > Js_int.max || 255 * 255 > Js_int.max;

function mulUnsafe$1(a, b) {
  return Math.imul(a, b);
}

var mul$1 = isMulMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckInteger$1(a * b);
    }) : (function (a, b) {
      return fromInt$1(Math.imul(a, b));
    });

var mulExn$1 = isMulMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$1(a * b);
    }) : (function (a, b) {
      return fromIntExn$1(Math.imul(a, b));
    });

var mulClamped$1 = isMulMaybeOverflow$1 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$1(a * b);
    }) : (function (a, b) {
      return fromIntClamped$1(Math.imul(a, b));
    });

function divUnsafe$1(a, b) {
  return a / b | 0;
}

function div$1(a, b) {
  if (b !== 0) {
    return divUnsafe$1(a, b);
  }
  
}

var divExn$1 = Caml_int32.div;

function remUnsafe$1(a, b) {
  return a % b | 0;
}

function rem$1(a, b) {
  if (b !== 0) {
    return remUnsafe$1(a, b);
  }
  
}

function remExn$1(a, b) {
  return Caml_int32.mod_(a, b) | 0;
}

var include$1 = ResNumber__Operation.MakeNumberSum({
      add: add$1,
      addExn: addExn$1,
      addClamped: addClamped$1,
      addUnsafe: addUnsafe$1
    });

function inc$1(n) {
  return add$1(n, 1);
}

function incExn$1(n) {
  return addExn$1(n, 1);
}

function incUnsafe$1(n) {
  return n + 1 | 0;
}

function dec$1(n) {
  return sub$1(n, 1);
}

function decExn$1(n) {
  return subExn$1(n, 1);
}

function decUnsafe$1(n) {
  return n - 1 | 0;
}

var isUnsigned$1 = true;

if (isUnsigned$1 && Math.pow(2.0, 8) - 1.0 !== 255) {
  PervasivesU.invalid_arg("invalid maxValue " + (255).toString() + " for " + (8).toString() + " bits unsigned integer");
}

var is32Bits$1 = false;

var mask$1 = 255;

PervasivesU.lnot(mask$1);

var lnot$1 = isUnsigned$1 ? (function (i) {
      return PervasivesU.lnot(i) & mask$1;
    }) : PervasivesU.lnot;

function land$1(prim0, prim1) {
  return prim0 & prim1;
}

function lor$1(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$1(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$1(n) {
  if (n < 0 || n >= 8) {
    return toUint32(n) % 8;
  } else {
    return n;
  }
}

var lsl$1 = is32Bits$1 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var m = modBits$1(n);
      if (m !== 0) {
        return (i << m) & mask$1;
      } else {
        return i;
      }
    });

var lsr$1 = is32Bits$1 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return (i >>> modBits$1(n)) | 0;
    });

var asr$1 = is32Bits$1 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$1(n));
    });

function rsl$1(i, n) {
  var m = modBits$1(n);
  if (m !== 0) {
    return lsl$1(i, m) | lsr$1(i, 8 - m | 0);
  } else {
    return i;
  }
}

function rsr$1(i, n) {
  var m = modBits$1(n);
  if (m !== 0) {
    return lsr$1(i, m) | lsl$1(i, 8 - m | 0);
  } else {
    return i;
  }
}

var clz$1 = is32Bits$1 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 24 | 0;
      } else {
        return c;
      }
    });

var imul$1 = is32Bits$1 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      return Math.imul(a, b) & mask$1;
    });

function pow_$1(base, exp) {
  return Math.pow(base, exp);
}

function pow$1(base, exp) {
  return fromFloat$1(pow_$1(base, exp));
}

function powExn$1(base, exp) {
  return fromFloatExn$1(pow_$1(base, exp));
}

function powUnsafe$1(base, exp) {
  return pow_$1(base, exp) | 0;
}

function random$1(min, max) {
  var min_ = min;
  var max_ = max;
  return fromFloatClamped$1(Math.floor(Math.random() * (max_ - min_) + min_));
}

var Uint8_sum = include$1.sum;

var Uint8_sumExn = include$1.sumExn;

var Uint8_sumUnsafe = include$1.sumUnsafe;

var Uint8 = {
  isSigned: false,
  isUnsigned: isUnsigned$1,
  bits: 8,
  fromInt: fromInt$1,
  fromIntExn: fromIntExn$1,
  fromIntClamped: fromIntClamped$1,
  fromIntUnsafe: fromIntUnsafe$1,
  toInt: toInt$1,
  toIntExn: toIntExn$1,
  toIntClamped: toIntClamped$1,
  toIntUnsafe: toIntUnsafe$1,
  fromFloat: fromFloat$1,
  fromFloatExn: fromFloatExn$1,
  fromFloatClamped: fromFloatClamped$1,
  fromFloatUnsafe: fromFloatUnsafe$1,
  toFloat: toFloat$1,
  fromString: fromString$1,
  fromStringExn: fromStringExn$1,
  toString: toString$1,
  toStringWithRadixExn: toStringWithRadixExn$1,
  toExponential: toExponential$1,
  toExponentialWithPrecisionExn: toExponentialWithPrecisionExn$1,
  toPrecision: toPrecision$1,
  toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn$1,
  fromStringWithRadix: fromStringWithRadix$1,
  fromStringWithRadixExn: fromStringWithRadixExn$1,
  zero: 0,
  one: 1,
  minValue: 0,
  maxValue: 255,
  compare: compare$1,
  compareExn: compareExn$1,
  eq: eq$1,
  ne: ne$1,
  lt: lt$1,
  le: le$1,
  gt: gt$1,
  ge: ge$1,
  min: min$1,
  minMany: minMany$1,
  minManyExn: minManyExn$1,
  minManyUnsafe: minManyUnsafe$1,
  max: max$1,
  maxMany: maxMany$1,
  maxManyExn: maxManyExn$1,
  maxManyUnsafe: maxManyUnsafe$1,
  add: add$1,
  addExn: addExn$1,
  addClamped: addClamped$1,
  addUnsafe: addUnsafe$1,
  sub: sub$1,
  subExn: subExn$1,
  subClamped: subClamped$1,
  subUnsafe: subUnsafe$1,
  mul: mul$1,
  mulExn: mulExn$1,
  mulClamped: mulClamped$1,
  mulUnsafe: mulUnsafe$1,
  div: div$1,
  divExn: divExn$1,
  divUnsafe: divUnsafe$1,
  rem: rem$1,
  remExn: remExn$1,
  remUnsafe: remUnsafe$1,
  sum: Uint8_sum,
  sumExn: Uint8_sumExn,
  sumUnsafe: Uint8_sumUnsafe,
  inc: inc$1,
  incExn: incExn$1,
  incUnsafe: incUnsafe$1,
  dec: dec$1,
  decExn: decExn$1,
  decUnsafe: decUnsafe$1,
  lnot: lnot$1,
  land: land$1,
  lor: lor$1,
  lxor: lxor$1,
  lsl: lsl$1,
  lsr: lsr$1,
  asr: asr$1,
  rsl: rsl$1,
  rsr: rsr$1,
  clz: clz$1,
  imul: imul$1,
  pow: pow$1,
  powExn: powExn$1,
  powUnsafe: powUnsafe$1,
  random: random$1
};

var IntRange$2 = {
  minValue: -32768,
  maxValue: 32767
};

function toString$2(i) {
  return i.toString();
}

if (-32768 < Js_int.min || 32767 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (-32768).toString() + ", maxValue: " + (32767).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$2 = -32768 === Js_int.min && 32767 === Js_int.max;

function fromIntUnsafe$2(i) {
  return i | 0;
}

var fromInt$2 = isInt32$2 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= -32768 && i <= 32767) {
        return i | 0;
      }
      
    });

var fromIntExn$2 = isInt32$2 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= -32768 && i <= 32767) {
        return i | 0;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$2);
      }
    });

var fromIntClamped$2 = isInt32$2 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i < -32768) {
        return -32768;
      } else if (i > 32767) {
        return 32767;
      } else {
        return i | 0;
      }
    });

function toInt$2(i) {
  return i;
}

function toIntExn$2(i) {
  return i;
}

function toIntClamped$2(i) {
  return i;
}

function toIntUnsafe$2(i) {
  return i;
}

function fromFloatUnsafe$2(f) {
  return f | 0;
}

function fromFloat$2(f) {
  if (Number.isInteger(f) && f >= -32768 && f <= 32767) {
    return f | 0;
  }
  
}

function fromFloatExn$2(f) {
  if (Number.isInteger(f)) {
    if (f < -32768 || f > 32767) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$2);
    } else {
      return f | 0;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
  }
}

function fromFloatClamped$2(f) {
  if (f < -32768) {
    return -32768;
  } else if (f > 32767) {
    return 32767;
  } else {
    return f | 0;
  }
}

function toFloat$2(i) {
  return i;
}

function fromString$2(s) {
  var f = parseInt(s, undefined);
  if (!Number.isNaN(f)) {
    return fromFloat$2(f);
  }
  
}

function fromStringExn$2(s) {
  var f = parseInt(s, undefined);
  if (Number.isNaN(f)) {
    return PervasivesU.invalid_arg("the string is not an integer: " + s);
  } else {
    return fromFloatExn$2(f);
  }
}

function toStringWithRadixExn$2(i, radix) {
  return i.toString(radix);
}

function toExponential$2(i) {
  return i.toExponential();
}

function toExponentialWithPrecisionExn$2(i, digits) {
  return i.toExponential(digits);
}

function toPrecision$2(i) {
  return i.toPrecision();
}

function toPrecisionWithPrecisionExn$2(i, digits) {
  return i.toPrecision(digits);
}

function fromStringWithRadix$2(s, radix) {
  var f = parseInt(s, radix);
  if (!Number.isNaN(f)) {
    return fromFloat$2(f);
  }
  
}

function fromStringWithRadixExn$2(s, radix) {
  var f = parseInt(s, radix);
  if (Number.isNaN(f)) {
    if (radix >= 2 && radix <= 36) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
    }
  } else {
    return fromFloatExn$2(f);
  }
}

function compareExn$2(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$2(a, b) {
  return compareExn$2(a, b);
}

function eq$2(a, b) {
  return a === b;
}

function ne$2(a, b) {
  return a !== b;
}

function lt$2(a, b) {
  return a < b;
}

function le$2(a, b) {
  return a <= b;
}

function gt$2(a, b) {
  return a > b;
}

function ge$2(a, b) {
  return a >= b;
}

function min$2(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$2(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$2(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function minManyUnsafe$2(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
}

function max$2(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$2(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$2(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function maxManyUnsafe$2(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
}

function fromFloatUncheckInteger$2(f) {
  if (f >= -32768 && f <= 32767) {
    return f | 0;
  }
  
}

function fromFloatUncheckIntegerExn$2(f) {
  if (f >= -32768 && f <= 32767) {
    return f | 0;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$2);
  }
}

function fromFloatUncheckIntegerClamped$2(f) {
  if (f < -32768) {
    return -32768;
  } else if (f > 32767) {
    return 32767;
  } else {
    return f | 0;
  }
}

var isAddMaybeOverflow$2 = -65536 < Js_int.min || 65534 > Js_int.max;

function addUnsafe$2(a, b) {
  return a + b | 0;
}

var add$2 = isAddMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckInteger$2(a + b);
    }) : (function (a, b) {
      return fromInt$2(a + b | 0);
    });

var addExn$2 = isAddMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$2(a + b);
    }) : (function (a, b) {
      return fromIntExn$2(a + b | 0);
    });

var addClamped$2 = isAddMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$2(a + b);
    }) : (function (a, b) {
      return fromIntClamped$2(a + b | 0);
    });

var isSubMaybeOverflow$2 = -65535 < Js_int.min || 65535 > Js_int.max;

function subUnsafe$2(a, b) {
  return a - b | 0;
}

var sub$2 = isSubMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckInteger$2(a - b);
    }) : (function (a, b) {
      return fromInt$2(a - b | 0);
    });

var subExn$2 = isSubMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$2(a - b);
    }) : (function (a, b) {
      return fromIntExn$2(a - b | 0);
    });

var subClamped$2 = isSubMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$2(a - b);
    }) : (function (a, b) {
      return fromIntClamped$2(a - b | 0);
    });

var isMulMaybeOverflow$2 = -32768 * 32767 < Js_int.min || -32768 * -32768 > Js_int.max || 32767 * 32767 > Js_int.max;

function mulUnsafe$2(a, b) {
  return Math.imul(a, b);
}

var mul$2 = isMulMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckInteger$2(a * b);
    }) : (function (a, b) {
      return fromInt$2(Math.imul(a, b));
    });

var mulExn$2 = isMulMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$2(a * b);
    }) : (function (a, b) {
      return fromIntExn$2(Math.imul(a, b));
    });

var mulClamped$2 = isMulMaybeOverflow$2 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$2(a * b);
    }) : (function (a, b) {
      return fromIntClamped$2(Math.imul(a, b));
    });

function divUnsafe$2(a, b) {
  return a / b | 0;
}

function div$2(a, b) {
  if (b !== 0) {
    return divUnsafe$2(a, b);
  }
  
}

var divExn$2 = Caml_int32.div;

function remUnsafe$2(a, b) {
  return a % b | 0;
}

function rem$2(a, b) {
  if (b !== 0) {
    return remUnsafe$2(a, b);
  }
  
}

function remExn$2(a, b) {
  return Caml_int32.mod_(a, b) | 0;
}

var include$2 = ResNumber__Operation.MakeNumberSum({
      add: add$2,
      addExn: addExn$2,
      addClamped: addClamped$2,
      addUnsafe: addUnsafe$2
    });

function inc$2(n) {
  return add$2(n, 1);
}

function incExn$2(n) {
  return addExn$2(n, 1);
}

function incUnsafe$2(n) {
  return n + 1 | 0;
}

function dec$2(n) {
  return sub$2(n, 1);
}

function decExn$2(n) {
  return subExn$2(n, 1);
}

function decUnsafe$2(n) {
  return n - 1 | 0;
}

var isUnsigned$2 = false;

var n$1 = Math.abs(-32768);

if (Math.log2(n$1) !== 15) {
  PervasivesU.invalid_arg("invalid minValue " + (-32768).toString() + " for " + (16).toString() + " bits signed integer");
}

if (n$1 - 1.0 !== 32767) {
  PervasivesU.invalid_arg("invalid maxValue " + (32767).toString() + " for " + (16).toString() + " bits signed integer");
}

if (isUnsigned$2) {
  PervasivesU.invalid_arg("invalid minValue " + (-32768).toString() + " for " + (16).toString() + " bits unsigned integer");
  if (Math.pow(2.0, 16) - 1.0 !== 32767) {
    PervasivesU.invalid_arg("invalid maxValue " + (32767).toString() + " for " + (16).toString() + " bits unsigned integer");
  }
  
}

var is32Bits$2 = false;

var mask$2 = 65535;

var maskNot$1 = PervasivesU.lnot(mask$2);

var highestBit$1 = 32768;

var lnot$2 = isUnsigned$2 ? (function (i) {
      return PervasivesU.lnot(i) & mask$2;
    }) : PervasivesU.lnot;

function land$2(prim0, prim1) {
  return prim0 & prim1;
}

function lor$2(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$2(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$2(n) {
  if (n < 0 || n >= 16) {
    return toUint32(n) % 16;
  } else {
    return n;
  }
}

var lsl$2 = is32Bits$2 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var m = modBits$2(n);
      if (m === 0) {
        return i;
      }
      var v = (i << m);
      if ((v & highestBit$1) === 0) {
        return v & mask$2;
      } else {
        return v | maskNot$1;
      }
    });

var lsr$2 = is32Bits$2 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      var m = modBits$2(n);
      if (m !== 0) {
        return ((i & mask$2) >>> m) | 0;
      } else {
        return i;
      }
    });

var asr$2 = is32Bits$2 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$2(n));
    });

function rsl$2(i, n) {
  var m = modBits$2(n);
  if (m !== 0) {
    return lsl$2(i, m) | lsr$2(i, 16 - m | 0);
  } else {
    return i;
  }
}

function rsr$2(i, n) {
  var m = modBits$2(n);
  if (m !== 0) {
    return lsr$2(i, m) | lsl$2(i, 16 - m | 0);
  } else {
    return i;
  }
}

var clz$2 = is32Bits$2 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 16 | 0;
      } else {
        return c;
      }
    });

var imul$2 = is32Bits$2 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      var i = Math.imul(a, b);
      if ((i & highestBit$1) === 0) {
        return i & mask$2;
      } else {
        return i | maskNot$1;
      }
    });

function pow_$2(base, exp) {
  return Math.pow(base, exp);
}

function pow$2(base, exp) {
  return fromFloat$2(pow_$2(base, exp));
}

function powExn$2(base, exp) {
  return fromFloatExn$2(pow_$2(base, exp));
}

function powUnsafe$2(base, exp) {
  return pow_$2(base, exp) | 0;
}

function random$2(min, max) {
  var min_ = min;
  var max_ = max;
  return fromFloatClamped$2(Math.floor(Math.random() * (max_ - min_) + min_));
}

function neg$1(i) {
  if (i !== -32768) {
    return -i | 0;
  }
  
}

function negExn$1(i) {
  var v = neg$1(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(- i, {
                minValue: -32768,
                maxValue: 32767
              });
  }
}

function negUnsafe$1(i) {
  return -i | 0;
}

function abs$1(i) {
  if (i !== -32768) {
    return Math.abs(i);
  }
  
}

function absExn$1(i) {
  var v = abs$1(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                minValue: -32768,
                maxValue: 32767
              });
  }
}

function absUnsafe$1(i) {
  return PervasivesU.abs(i);
}

function signExn$1(i) {
  var match = Math.sign(i);
  switch (match) {
    case -1 :
        return -1;
    case 0 :
        return 0;
    case 1 :
        return 1;
    default:
      return 0;
  }
}

function sign$1(i) {
  return signExn$1(i);
}

function signRaw$1(i) {
  return Math.sign(i);
}

var Int16_sum = include$2.sum;

var Int16_sumExn = include$2.sumExn;

var Int16_sumUnsafe = include$2.sumUnsafe;

var Int16 = {
  isSigned: true,
  isUnsigned: isUnsigned$2,
  bits: 16,
  fromInt: fromInt$2,
  fromIntExn: fromIntExn$2,
  fromIntClamped: fromIntClamped$2,
  fromIntUnsafe: fromIntUnsafe$2,
  toInt: toInt$2,
  toIntExn: toIntExn$2,
  toIntClamped: toIntClamped$2,
  toIntUnsafe: toIntUnsafe$2,
  fromFloat: fromFloat$2,
  fromFloatExn: fromFloatExn$2,
  fromFloatClamped: fromFloatClamped$2,
  fromFloatUnsafe: fromFloatUnsafe$2,
  toFloat: toFloat$2,
  fromString: fromString$2,
  fromStringExn: fromStringExn$2,
  toString: toString$2,
  toStringWithRadixExn: toStringWithRadixExn$2,
  toExponential: toExponential$2,
  toExponentialWithPrecisionExn: toExponentialWithPrecisionExn$2,
  toPrecision: toPrecision$2,
  toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn$2,
  fromStringWithRadix: fromStringWithRadix$2,
  fromStringWithRadixExn: fromStringWithRadixExn$2,
  zero: 0,
  one: 1,
  minValue: -32768,
  maxValue: 32767,
  compare: compare$2,
  compareExn: compareExn$2,
  eq: eq$2,
  ne: ne$2,
  lt: lt$2,
  le: le$2,
  gt: gt$2,
  ge: ge$2,
  min: min$2,
  minMany: minMany$2,
  minManyExn: minManyExn$2,
  minManyUnsafe: minManyUnsafe$2,
  max: max$2,
  maxMany: maxMany$2,
  maxManyExn: maxManyExn$2,
  maxManyUnsafe: maxManyUnsafe$2,
  add: add$2,
  addExn: addExn$2,
  addClamped: addClamped$2,
  addUnsafe: addUnsafe$2,
  sub: sub$2,
  subExn: subExn$2,
  subClamped: subClamped$2,
  subUnsafe: subUnsafe$2,
  mul: mul$2,
  mulExn: mulExn$2,
  mulClamped: mulClamped$2,
  mulUnsafe: mulUnsafe$2,
  div: div$2,
  divExn: divExn$2,
  divUnsafe: divUnsafe$2,
  rem: rem$2,
  remExn: remExn$2,
  remUnsafe: remUnsafe$2,
  sum: Int16_sum,
  sumExn: Int16_sumExn,
  sumUnsafe: Int16_sumUnsafe,
  inc: inc$2,
  incExn: incExn$2,
  incUnsafe: incUnsafe$2,
  dec: dec$2,
  decExn: decExn$2,
  decUnsafe: decUnsafe$2,
  lnot: lnot$2,
  land: land$2,
  lor: lor$2,
  lxor: lxor$2,
  lsl: lsl$2,
  lsr: lsr$2,
  asr: asr$2,
  rsl: rsl$2,
  rsr: rsr$2,
  clz: clz$2,
  imul: imul$2,
  pow: pow$2,
  powExn: powExn$2,
  powUnsafe: powUnsafe$2,
  random: random$2,
  neg: neg$1,
  negExn: negExn$1,
  negUnsafe: negUnsafe$1,
  abs: abs$1,
  absExn: absExn$1,
  absUnsafe: absUnsafe$1,
  sign: sign$1,
  signExn: signExn$1,
  signRaw: signRaw$1
};

var IntRange$3 = {
  minValue: 0,
  maxValue: 65535
};

function toString$3(i) {
  return i.toString();
}

if (0 < Js_int.min || 65535 > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (0).toString() + ", maxValue: " + (65535).toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$3 = 0 === Js_int.min && 65535 === Js_int.max;

function fromIntUnsafe$3(i) {
  return i | 0;
}

var fromInt$3 = isInt32$3 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= 0 && i <= 65535) {
        return i | 0;
      }
      
    });

var fromIntExn$3 = isInt32$3 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= 0 && i <= 65535) {
        return i | 0;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$3);
      }
    });

var fromIntClamped$3 = isInt32$3 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i < 0) {
        return 0;
      } else if (i > 65535) {
        return 65535;
      } else {
        return i | 0;
      }
    });

function toInt$3(i) {
  return i;
}

function toIntExn$3(i) {
  return i;
}

function toIntClamped$3(i) {
  return i;
}

function toIntUnsafe$3(i) {
  return i;
}

function fromFloatUnsafe$3(f) {
  return f | 0;
}

function fromFloat$3(f) {
  if (Number.isInteger(f) && f >= 0 && f <= 65535) {
    return f | 0;
  }
  
}

function fromFloatExn$3(f) {
  if (Number.isInteger(f)) {
    if (f < 0 || f > 65535) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$3);
    } else {
      return f | 0;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
  }
}

function fromFloatClamped$3(f) {
  if (f < 0) {
    return 0;
  } else if (f > 65535) {
    return 65535;
  } else {
    return f | 0;
  }
}

function toFloat$3(i) {
  return i;
}

function fromString$3(s) {
  var f = parseInt(s, undefined);
  if (!Number.isNaN(f)) {
    return fromFloat$3(f);
  }
  
}

function fromStringExn$3(s) {
  var f = parseInt(s, undefined);
  if (Number.isNaN(f)) {
    return PervasivesU.invalid_arg("the string is not an integer: " + s);
  } else {
    return fromFloatExn$3(f);
  }
}

function toStringWithRadixExn$3(i, radix) {
  return i.toString(radix);
}

function toExponential$3(i) {
  return i.toExponential();
}

function toExponentialWithPrecisionExn$3(i, digits) {
  return i.toExponential(digits);
}

function toPrecision$3(i) {
  return i.toPrecision();
}

function toPrecisionWithPrecisionExn$3(i, digits) {
  return i.toPrecision(digits);
}

function fromStringWithRadix$3(s, radix) {
  var f = parseInt(s, radix);
  if (!Number.isNaN(f)) {
    return fromFloat$3(f);
  }
  
}

function fromStringWithRadixExn$3(s, radix) {
  var f = parseInt(s, radix);
  if (Number.isNaN(f)) {
    if (radix >= 2 && radix <= 36) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
    }
  } else {
    return fromFloatExn$3(f);
  }
}

function compareExn$3(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$3(a, b) {
  return compareExn$3(a, b);
}

function eq$3(a, b) {
  return a === b;
}

function ne$3(a, b) {
  return a !== b;
}

function lt$3(a, b) {
  return a < b;
}

function le$3(a, b) {
  return a <= b;
}

function gt$3(a, b) {
  return a > b;
}

function ge$3(a, b) {
  return a >= b;
}

function min$3(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$3(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$3(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function minManyUnsafe$3(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
}

function max$3(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$3(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$3(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function maxManyUnsafe$3(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
}

function fromFloatUncheckInteger$3(f) {
  if (f >= 0 && f <= 65535) {
    return f | 0;
  }
  
}

function fromFloatUncheckIntegerExn$3(f) {
  if (f >= 0 && f <= 65535) {
    return f | 0;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$3);
  }
}

function fromFloatUncheckIntegerClamped$3(f) {
  if (f < 0) {
    return 0;
  } else if (f > 65535) {
    return 65535;
  } else {
    return f | 0;
  }
}

var isAddMaybeOverflow$3 = 0 < Js_int.min || 131070 > Js_int.max;

function addUnsafe$3(a, b) {
  return a + b | 0;
}

var add$3 = isAddMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckInteger$3(a + b);
    }) : (function (a, b) {
      return fromInt$3(a + b | 0);
    });

var addExn$3 = isAddMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$3(a + b);
    }) : (function (a, b) {
      return fromIntExn$3(a + b | 0);
    });

var addClamped$3 = isAddMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$3(a + b);
    }) : (function (a, b) {
      return fromIntClamped$3(a + b | 0);
    });

var isSubMaybeOverflow$3 = -65535 < Js_int.min || 65535 > Js_int.max;

function subUnsafe$3(a, b) {
  return a - b | 0;
}

var sub$3 = isSubMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckInteger$3(a - b);
    }) : (function (a, b) {
      return fromInt$3(a - b | 0);
    });

var subExn$3 = isSubMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$3(a - b);
    }) : (function (a, b) {
      return fromIntExn$3(a - b | 0);
    });

var subClamped$3 = isSubMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$3(a - b);
    }) : (function (a, b) {
      return fromIntClamped$3(a - b | 0);
    });

var isMulMaybeOverflow$3 = 0 * 65535 < Js_int.min || 0 * 0 > Js_int.max || 65535 * 65535 > Js_int.max;

function mulUnsafe$3(a, b) {
  return Math.imul(a, b);
}

var mul$3 = isMulMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckInteger$3(a * b);
    }) : (function (a, b) {
      return fromInt$3(Math.imul(a, b));
    });

var mulExn$3 = isMulMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$3(a * b);
    }) : (function (a, b) {
      return fromIntExn$3(Math.imul(a, b));
    });

var mulClamped$3 = isMulMaybeOverflow$3 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$3(a * b);
    }) : (function (a, b) {
      return fromIntClamped$3(Math.imul(a, b));
    });

function divUnsafe$3(a, b) {
  return a / b | 0;
}

function div$3(a, b) {
  if (b !== 0) {
    return divUnsafe$3(a, b);
  }
  
}

var divExn$3 = Caml_int32.div;

function remUnsafe$3(a, b) {
  return a % b | 0;
}

function rem$3(a, b) {
  if (b !== 0) {
    return remUnsafe$3(a, b);
  }
  
}

function remExn$3(a, b) {
  return Caml_int32.mod_(a, b) | 0;
}

var include$3 = ResNumber__Operation.MakeNumberSum({
      add: add$3,
      addExn: addExn$3,
      addClamped: addClamped$3,
      addUnsafe: addUnsafe$3
    });

function inc$3(n) {
  return add$3(n, 1);
}

function incExn$3(n) {
  return addExn$3(n, 1);
}

function incUnsafe$3(n) {
  return n + 1 | 0;
}

function dec$3(n) {
  return sub$3(n, 1);
}

function decExn$3(n) {
  return subExn$3(n, 1);
}

function decUnsafe$3(n) {
  return n - 1 | 0;
}

var isUnsigned$3 = true;

if (isUnsigned$3 && Math.pow(2.0, 16) - 1.0 !== 65535) {
  PervasivesU.invalid_arg("invalid maxValue " + (65535).toString() + " for " + (16).toString() + " bits unsigned integer");
}

var is32Bits$3 = false;

var mask$3 = 65535;

PervasivesU.lnot(mask$3);

var lnot$3 = isUnsigned$3 ? (function (i) {
      return PervasivesU.lnot(i) & mask$3;
    }) : PervasivesU.lnot;

function land$3(prim0, prim1) {
  return prim0 & prim1;
}

function lor$3(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$3(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$3(n) {
  if (n < 0 || n >= 16) {
    return toUint32(n) % 16;
  } else {
    return n;
  }
}

var lsl$3 = is32Bits$3 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var m = modBits$3(n);
      if (m !== 0) {
        return (i << m) & mask$3;
      } else {
        return i;
      }
    });

var lsr$3 = is32Bits$3 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      return (i >>> modBits$3(n)) | 0;
    });

var asr$3 = is32Bits$3 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$3(n));
    });

function rsl$3(i, n) {
  var m = modBits$3(n);
  if (m !== 0) {
    return lsl$3(i, m) | lsr$3(i, 16 - m | 0);
  } else {
    return i;
  }
}

function rsr$3(i, n) {
  var m = modBits$3(n);
  if (m !== 0) {
    return lsr$3(i, m) | lsl$3(i, 16 - m | 0);
  } else {
    return i;
  }
}

var clz$3 = is32Bits$3 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 16 | 0;
      } else {
        return c;
      }
    });

var imul$3 = is32Bits$3 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      return Math.imul(a, b) & mask$3;
    });

function pow_$3(base, exp) {
  return Math.pow(base, exp);
}

function pow$3(base, exp) {
  return fromFloat$3(pow_$3(base, exp));
}

function powExn$3(base, exp) {
  return fromFloatExn$3(pow_$3(base, exp));
}

function powUnsafe$3(base, exp) {
  return pow_$3(base, exp) | 0;
}

function random$3(min, max) {
  var min_ = min;
  var max_ = max;
  return fromFloatClamped$3(Math.floor(Math.random() * (max_ - min_) + min_));
}

var Uint16_sum = include$3.sum;

var Uint16_sumExn = include$3.sumExn;

var Uint16_sumUnsafe = include$3.sumUnsafe;

var Uint16 = {
  isSigned: false,
  isUnsigned: isUnsigned$3,
  bits: 16,
  fromInt: fromInt$3,
  fromIntExn: fromIntExn$3,
  fromIntClamped: fromIntClamped$3,
  fromIntUnsafe: fromIntUnsafe$3,
  toInt: toInt$3,
  toIntExn: toIntExn$3,
  toIntClamped: toIntClamped$3,
  toIntUnsafe: toIntUnsafe$3,
  fromFloat: fromFloat$3,
  fromFloatExn: fromFloatExn$3,
  fromFloatClamped: fromFloatClamped$3,
  fromFloatUnsafe: fromFloatUnsafe$3,
  toFloat: toFloat$3,
  fromString: fromString$3,
  fromStringExn: fromStringExn$3,
  toString: toString$3,
  toStringWithRadixExn: toStringWithRadixExn$3,
  toExponential: toExponential$3,
  toExponentialWithPrecisionExn: toExponentialWithPrecisionExn$3,
  toPrecision: toPrecision$3,
  toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn$3,
  fromStringWithRadix: fromStringWithRadix$3,
  fromStringWithRadixExn: fromStringWithRadixExn$3,
  zero: 0,
  one: 1,
  minValue: 0,
  maxValue: 65535,
  compare: compare$3,
  compareExn: compareExn$3,
  eq: eq$3,
  ne: ne$3,
  lt: lt$3,
  le: le$3,
  gt: gt$3,
  ge: ge$3,
  min: min$3,
  minMany: minMany$3,
  minManyExn: minManyExn$3,
  minManyUnsafe: minManyUnsafe$3,
  max: max$3,
  maxMany: maxMany$3,
  maxManyExn: maxManyExn$3,
  maxManyUnsafe: maxManyUnsafe$3,
  add: add$3,
  addExn: addExn$3,
  addClamped: addClamped$3,
  addUnsafe: addUnsafe$3,
  sub: sub$3,
  subExn: subExn$3,
  subClamped: subClamped$3,
  subUnsafe: subUnsafe$3,
  mul: mul$3,
  mulExn: mulExn$3,
  mulClamped: mulClamped$3,
  mulUnsafe: mulUnsafe$3,
  div: div$3,
  divExn: divExn$3,
  divUnsafe: divUnsafe$3,
  rem: rem$3,
  remExn: remExn$3,
  remUnsafe: remUnsafe$3,
  sum: Uint16_sum,
  sumExn: Uint16_sumExn,
  sumUnsafe: Uint16_sumUnsafe,
  inc: inc$3,
  incExn: incExn$3,
  incUnsafe: incUnsafe$3,
  dec: dec$3,
  decExn: decExn$3,
  decUnsafe: decUnsafe$3,
  lnot: lnot$3,
  land: land$3,
  lor: lor$3,
  lxor: lxor$3,
  lsl: lsl$3,
  lsr: lsr$3,
  asr: asr$3,
  rsl: rsl$3,
  rsr: rsr$3,
  clz: clz$3,
  imul: imul$3,
  pow: pow$3,
  powExn: powExn$3,
  powUnsafe: powUnsafe$3,
  random: random$3
};

var IntRange$4 = {
  minValue: Js_int.min,
  maxValue: Js_int.max
};

function toString$4(i) {
  return i.toString();
}

if (Js_int.min > Js_int.max) {
  PervasivesU.invalid_arg("minValue " + Js_int.min.toString() + " is greater than maxValue " + Js_int.max.toString());
}

if (Js_int.min < Js_int.min || Js_int.max > Js_int.max) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + Js_int.min.toString() + ", maxValue: " + Js_int.max.toString() + ", max range: " + Js_int.min.toString() + " - " + Js_int.max.toString());
}

var isInt32$4 = Js_int.min === Js_int.min && Js_int.max === Js_int.max;

function fromIntUnsafe$4(i) {
  return i | 0;
}

var fromInt$4 = isInt32$4 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= Js_int.min && i <= Js_int.max) {
        return i | 0;
      }
      
    });

var fromIntExn$4 = isInt32$4 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i >= Js_int.min && i <= Js_int.max) {
        return i | 0;
      } else {
        return ResNumber__Utils.raiseOverflow(i, IntRange$4);
      }
    });

var fromIntClamped$4 = isInt32$4 ? (function (i) {
      return i | 0;
    }) : (function (i) {
      if (i < Js_int.min) {
        return Js_int.min;
      } else if (i > Js_int.max) {
        return Js_int.max;
      } else {
        return i | 0;
      }
    });

function toInt$4(i) {
  return i;
}

function toIntExn$4(i) {
  return i;
}

function toIntClamped$4(i) {
  return i;
}

function toIntUnsafe$4(i) {
  return i;
}

function fromFloatUnsafe$4(f) {
  return f | 0;
}

function fromFloat$4(f) {
  if (Number.isInteger(f) && f >= Js_int.min && f <= Js_int.max) {
    return f | 0;
  }
  
}

function fromFloatExn$4(f) {
  if (Number.isInteger(f)) {
    if (f < Js_int.min || f > Js_int.max) {
      return ResNumber__Utils.raiseOverflow(f, IntRange$4);
    } else {
      return f | 0;
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
  }
}

function fromFloatClamped$4(f) {
  if (f < Js_int.min) {
    return Js_int.min;
  } else if (f > Js_int.max) {
    return Js_int.max;
  } else {
    return f | 0;
  }
}

function toFloat$4(i) {
  return i;
}

function fromString$4(s) {
  var f = parseInt(s, undefined);
  if (!Number.isNaN(f)) {
    return fromFloat$4(f);
  }
  
}

function fromStringExn$4(s) {
  var f = parseInt(s, undefined);
  if (Number.isNaN(f)) {
    return PervasivesU.invalid_arg("the string is not an integer: " + s);
  } else {
    return fromFloatExn$4(f);
  }
}

function toStringWithRadixExn$4(i, radix) {
  return i.toString(radix);
}

function toExponential$4(i) {
  return i.toExponential();
}

function toExponentialWithPrecisionExn$4(i, digits) {
  return i.toExponential(digits);
}

function toPrecision$4(i) {
  return i.toPrecision();
}

function toPrecisionWithPrecisionExn$4(i, digits) {
  return i.toPrecision(digits);
}

if (Js_int.min > 0 || Js_int.max < 1) {
  PervasivesU.invalid_arg((0).toString() + " and " + (1).toString() + " must be between minValue " + Js_int.min.toString() + " and maxValue " + Js_int.max.toString());
}

function fromStringWithRadix$4(s, radix) {
  var f = parseInt(s, radix);
  if (!Number.isNaN(f)) {
    return fromFloat$4(f);
  }
  
}

function fromStringWithRadixExn$4(s, radix) {
  var f = parseInt(s, radix);
  if (Number.isNaN(f)) {
    if (radix >= 2 && radix <= 36) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
    }
  } else {
    return fromFloatExn$4(f);
  }
}

function compareExn$4(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$4(a, b) {
  return compareExn$4(a, b);
}

function eq$4(a, b) {
  return a === b;
}

function ne$4(a, b) {
  return a !== b;
}

function lt$4(a, b) {
  return a < b;
}

function le$4(a, b) {
  return a <= b;
}

function gt$4(a, b) {
  return a > b;
}

function ge$4(a, b) {
  return a >= b;
}

function min$4(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$4(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$4(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function minManyUnsafe$4(arr) {
  return Caml_splice_call.spliceApply(Math.min, [arr]) | 0;
}

function max$4(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$4(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$4(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function maxManyUnsafe$4(arr) {
  return Caml_splice_call.spliceApply(Math.max, [arr]) | 0;
}

function fromFloatUncheckInteger$4(f) {
  if (f >= Js_int.min && f <= Js_int.max) {
    return f | 0;
  }
  
}

function fromFloatUncheckIntegerExn$4(f) {
  if (f >= Js_int.min && f <= Js_int.max) {
    return f | 0;
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntRange$4);
  }
}

function fromFloatUncheckIntegerClamped$4(f) {
  if (f < Js_int.min) {
    return Js_int.min;
  } else if (f > Js_int.max) {
    return Js_int.max;
  } else {
    return f | 0;
  }
}

var isAddMaybeOverflow$4 = Js_int.min + Js_int.min < Js_int.min || Js_int.max + Js_int.max > Js_int.max;

function addUnsafe$4(a, b) {
  return a + b | 0;
}

var add$4 = isAddMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckInteger$4(a + b);
    }) : (function (a, b) {
      return fromInt$4(a + b | 0);
    });

var addExn$4 = isAddMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$4(a + b);
    }) : (function (a, b) {
      return fromIntExn$4(a + b | 0);
    });

var addClamped$4 = isAddMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$4(a + b);
    }) : (function (a, b) {
      return fromIntClamped$4(a + b | 0);
    });

var isSubMaybeOverflow$4 = Js_int.min - Js_int.max < Js_int.min || Js_int.max - Js_int.min > Js_int.max;

function subUnsafe$4(a, b) {
  return a - b | 0;
}

var sub$4 = isSubMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckInteger$4(a - b);
    }) : (function (a, b) {
      return fromInt$4(a - b | 0);
    });

var subExn$4 = isSubMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$4(a - b);
    }) : (function (a, b) {
      return fromIntExn$4(a - b | 0);
    });

var subClamped$4 = isSubMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$4(a - b);
    }) : (function (a, b) {
      return fromIntClamped$4(a - b | 0);
    });

var isMulMaybeOverflow$4 = Js_int.min * Js_int.max < Js_int.min || Js_int.min * Js_int.min > Js_int.max || Js_int.max * Js_int.max > Js_int.max;

function mulUnsafe$4(a, b) {
  return Math.imul(a, b);
}

var mul$4 = isMulMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckInteger$4(a * b);
    }) : (function (a, b) {
      return fromInt$4(Math.imul(a, b));
    });

var mulExn$4 = isMulMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerExn$4(a * b);
    }) : (function (a, b) {
      return fromIntExn$4(Math.imul(a, b));
    });

var mulClamped$4 = isMulMaybeOverflow$4 ? (function (a, b) {
      return fromFloatUncheckIntegerClamped$4(a * b);
    }) : (function (a, b) {
      return fromIntClamped$4(Math.imul(a, b));
    });

function divUnsafe$4(a, b) {
  return a / b | 0;
}

function div$4(a, b) {
  if (b !== 0) {
    return divUnsafe$4(a, b);
  }
  
}

var divExn$4 = Caml_int32.div;

function remUnsafe$4(a, b) {
  return a % b | 0;
}

function rem$4(a, b) {
  if (b !== 0) {
    return remUnsafe$4(a, b);
  }
  
}

function remExn$4(a, b) {
  return Caml_int32.mod_(a, b) | 0;
}

var include$4 = ResNumber__Operation.MakeNumberSum({
      add: add$4,
      addExn: addExn$4,
      addClamped: addClamped$4,
      addUnsafe: addUnsafe$4
    });

function inc$4(n) {
  return add$4(n, 1);
}

function incExn$4(n) {
  return addExn$4(n, 1);
}

function incUnsafe$4(n) {
  return n + 1 | 0;
}

function dec$4(n) {
  return sub$4(n, 1);
}

function decExn$4(n) {
  return subExn$4(n, 1);
}

function decUnsafe$4(n) {
  return n - 1 | 0;
}

var isUnsigned$4 = false;

if (Js_int.min >= 0) {
  PervasivesU.invalid_arg("minValue for signed integer must be less than 0: " + Js_int.min.toString());
}

var n$2 = Math.abs(Js_int.min);

if (Math.log2(n$2) !== 31) {
  PervasivesU.invalid_arg("invalid minValue " + Js_int.min.toString() + " for " + (32).toString() + " bits signed integer");
}

if (n$2 - 1.0 !== Js_int.max) {
  PervasivesU.invalid_arg("invalid maxValue " + Js_int.max.toString() + " for " + (32).toString() + " bits signed integer");
}

if (isUnsigned$4) {
  if (Js_int.min !== 0) {
    PervasivesU.invalid_arg("invalid minValue " + Js_int.min.toString() + " for " + (32).toString() + " bits unsigned integer");
  }
  if (Math.pow(2.0, 32) - 1.0 !== Js_int.max) {
    PervasivesU.invalid_arg("invalid maxValue " + Js_int.max.toString() + " for " + (32).toString() + " bits unsigned integer");
  }
  
}

var is32Bits$4 = true;

var mask$4 = -1;

var maskNot$2 = PervasivesU.lnot(mask$4);

var highestBit$2 = -2147483648;

var lnot$4 = isUnsigned$4 ? (function (i) {
      return PervasivesU.lnot(i) & mask$4;
    }) : PervasivesU.lnot;

function land$4(prim0, prim1) {
  return prim0 & prim1;
}

function lor$4(prim0, prim1) {
  return prim0 | prim1;
}

function lxor$4(prim0, prim1) {
  return prim0 ^ prim1;
}

function modBits$4(n) {
  if (n < 0 || n >= 32) {
    return toUint32(n) % 32;
  } else {
    return n;
  }
}

var lsl$4 = is32Bits$4 ? (function (prim0, prim1) {
      return (prim0 << prim1);
    }) : (function (i, n) {
      var m = modBits$4(n);
      if (m === 0) {
        return i;
      }
      var v = (i << m);
      if ((v & highestBit$2) === 0) {
        return v & mask$4;
      } else {
        return v | maskNot$2;
      }
    });

var lsr$4 = is32Bits$4 ? (function (prim0, prim1) {
      return (prim0 >>> prim1) | 0;
    }) : (function (i, n) {
      var m = modBits$4(n);
      if (m !== 0) {
        return ((i & mask$4) >>> m) | 0;
      } else {
        return i;
      }
    });

var asr$4 = is32Bits$4 ? (function (prim0, prim1) {
      return (prim0 >> prim1);
    }) : (function (i, n) {
      return (i >> modBits$4(n));
    });

function rsl$4(i, n) {
  var m = modBits$4(n);
  if (m !== 0) {
    return lsl$4(i, m) | lsr$4(i, 32 - m | 0);
  } else {
    return i;
  }
}

function rsr$4(i, n) {
  var m = modBits$4(n);
  if (m !== 0) {
    return lsr$4(i, m) | lsl$4(i, 32 - m | 0);
  } else {
    return i;
  }
}

var clz$4 = is32Bits$4 ? (function (i) {
      return Math.clz32(i);
    }) : (function (i) {
      var c = Math.clz32(i);
      if (c > 0) {
        return c - 0 | 0;
      } else {
        return c;
      }
    });

var imul$4 = is32Bits$4 ? (function (a, b) {
      return Math.imul(a, b);
    }) : (function (a, b) {
      var i = Math.imul(a, b);
      if ((i & highestBit$2) === 0) {
        return i & mask$4;
      } else {
        return i | maskNot$2;
      }
    });

function pow_$4(base, exp) {
  return Math.pow(base, exp);
}

function pow$4(base, exp) {
  return fromFloat$4(pow_$4(base, exp));
}

function powExn$4(base, exp) {
  return fromFloatExn$4(pow_$4(base, exp));
}

function powUnsafe$4(base, exp) {
  return pow_$4(base, exp) | 0;
}

function random$4(min, max) {
  var min_ = min;
  var max_ = max;
  return fromFloatClamped$4(Math.floor(Math.random() * (max_ - min_) + min_));
}

function neg$2(i) {
  if (i !== Js_int.min) {
    return -i | 0;
  }
  
}

function negExn$2(i) {
  var v = neg$2(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(- i, {
                minValue: Js_int.min,
                maxValue: Js_int.max
              });
  }
}

function negUnsafe$2(i) {
  return -i | 0;
}

function abs$2(i) {
  if (i !== Js_int.min) {
    return Math.abs(i);
  }
  
}

function absExn$2(i) {
  var v = abs$2(i);
  if (v !== undefined) {
    return v;
  } else {
    return ResNumber__Utils.raiseOverflow(Math.abs(i), {
                minValue: Js_int.min,
                maxValue: Js_int.max
              });
  }
}

function absUnsafe$2(i) {
  return PervasivesU.abs(i);
}

function signExn$2(i) {
  var match = Math.sign(i);
  switch (match) {
    case -1 :
        return -1;
    case 0 :
        return 0;
    case 1 :
        return 1;
    default:
      return 0;
  }
}

function sign$2(i) {
  return signExn$2(i);
}

function signRaw$2(i) {
  return Math.sign(i);
}

var Int32_sum = include$4.sum;

var Int32_sumExn = include$4.sumExn;

var Int32_sumUnsafe = include$4.sumUnsafe;

var Int32 = {
  isSigned: true,
  isUnsigned: isUnsigned$4,
  bits: 32,
  fromInt: fromInt$4,
  fromIntExn: fromIntExn$4,
  fromIntClamped: fromIntClamped$4,
  fromIntUnsafe: fromIntUnsafe$4,
  toInt: toInt$4,
  toIntExn: toIntExn$4,
  toIntClamped: toIntClamped$4,
  toIntUnsafe: toIntUnsafe$4,
  fromFloat: fromFloat$4,
  fromFloatExn: fromFloatExn$4,
  fromFloatClamped: fromFloatClamped$4,
  fromFloatUnsafe: fromFloatUnsafe$4,
  toFloat: toFloat$4,
  fromString: fromString$4,
  fromStringExn: fromStringExn$4,
  toString: toString$4,
  toStringWithRadixExn: toStringWithRadixExn$4,
  toExponential: toExponential$4,
  toExponentialWithPrecisionExn: toExponentialWithPrecisionExn$4,
  toPrecision: toPrecision$4,
  toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn$4,
  fromStringWithRadix: fromStringWithRadix$4,
  fromStringWithRadixExn: fromStringWithRadixExn$4,
  zero: 0,
  one: 1,
  minValue: Js_int.min,
  maxValue: Js_int.max,
  compare: compare$4,
  compareExn: compareExn$4,
  eq: eq$4,
  ne: ne$4,
  lt: lt$4,
  le: le$4,
  gt: gt$4,
  ge: ge$4,
  min: min$4,
  minMany: minMany$4,
  minManyExn: minManyExn$4,
  minManyUnsafe: minManyUnsafe$4,
  max: max$4,
  maxMany: maxMany$4,
  maxManyExn: maxManyExn$4,
  maxManyUnsafe: maxManyUnsafe$4,
  add: add$4,
  addExn: addExn$4,
  addClamped: addClamped$4,
  addUnsafe: addUnsafe$4,
  sub: sub$4,
  subExn: subExn$4,
  subClamped: subClamped$4,
  subUnsafe: subUnsafe$4,
  mul: mul$4,
  mulExn: mulExn$4,
  mulClamped: mulClamped$4,
  mulUnsafe: mulUnsafe$4,
  div: div$4,
  divExn: divExn$4,
  divUnsafe: divUnsafe$4,
  rem: rem$4,
  remExn: remExn$4,
  remUnsafe: remUnsafe$4,
  sum: Int32_sum,
  sumExn: Int32_sumExn,
  sumUnsafe: Int32_sumUnsafe,
  inc: inc$4,
  incExn: incExn$4,
  incUnsafe: incUnsafe$4,
  dec: dec$4,
  decExn: decExn$4,
  decUnsafe: decUnsafe$4,
  lnot: lnot$4,
  land: land$4,
  lor: lor$4,
  lxor: lxor$4,
  lsl: lsl$4,
  lsr: lsr$4,
  asr: asr$4,
  rsl: rsl$4,
  rsr: rsr$4,
  clz: clz$4,
  imul: imul$4,
  pow: pow$4,
  powExn: powExn$4,
  powUnsafe: powUnsafe$4,
  random: random$4,
  neg: neg$2,
  negExn: negExn$2,
  negUnsafe: negUnsafe$2,
  abs: abs$2,
  absExn: absExn$2,
  absUnsafe: absUnsafe$2,
  sign: sign$2,
  signExn: signExn$2,
  signRaw: signRaw$2
};

function fromIntUnsafe$5(i) {
  return toUint32(i);
}

function fromFloatUnsafe$5(f) {
  return toUint32(f);
}

var IntModule = {
  minValue: 0.0,
  maxValue: 4294967295.0,
  fromIntUnsafe: fromIntUnsafe$5,
  fromFloatUnsafe: fromFloatUnsafe$5
};

function toString$5(i) {
  return i.toString();
}

if (0.0 < Number.MIN_SAFE_INTEGER || 4294967295.0 > Number.MAX_SAFE_INTEGER) {
  PervasivesU.invalid_arg("the range of integer overflows, minValue: " + (0.0).toString() + ", maxValue: " + (4294967295.0).toString() + ", range: " + Number.MIN_SAFE_INTEGER.toString() + " - " + Number.MAX_SAFE_INTEGER.toString());
}

function fromInt$5(i) {
  if (i >= 0.0 && i <= 4294967295.0) {
    return toUint32(i);
  }
  
}

function fromIntExn$5(i) {
  if (i >= 0.0 && i <= 4294967295.0) {
    return toUint32(i);
  } else {
    return ResNumber__Utils.raiseOverflow(i, IntModule);
  }
}

function fromIntClamped$5(i) {
  if (i < 0.0) {
    return 0.0;
  } else if (i > 4294967295.0) {
    return 4294967295.0;
  } else {
    return toUint32(i);
  }
}

function toInt$5(i) {
  if (ResNumber__Utils.inInt32Range(i)) {
    return i;
  }
  
}

function toIntExn$5(i) {
  if (ResNumber__Utils.inInt32Range(i)) {
    return i;
  } else {
    return ResNumber__Utils.raiseOverflow(i, ResNumber__Utils.Int32Range);
  }
}

function toIntClamped$5(i) {
  if (i < Js_int.min) {
    return Js_int.min;
  } else if (i > Js_int.max) {
    return Js_int.max;
  } else {
    return i;
  }
}

function toIntUnsafe$5(i) {
  return i | 0;
}

function fromFloat$5(f) {
  if (Number.isInteger(f) && f >= 0.0 && f <= 4294967295.0) {
    return toUint32(f);
  }
  
}

function fromFloatExn$5(f) {
  if (Number.isInteger(f)) {
    if (f < 0.0 || f > 4294967295.0) {
      return ResNumber__Utils.raiseOverflow(f, IntModule);
    } else {
      return toUint32(f);
    }
  } else {
    return PervasivesU.invalid_arg("float number " + f.toString() + " is not an integer");
  }
}

function fromFloatClamped$5(f) {
  if (f < 0.0) {
    return 0.0;
  } else if (f > 4294967295.0) {
    return 4294967295.0;
  } else {
    return toUint32(f);
  }
}

function toFloat$5(f) {
  return f;
}

function fromString$5(s) {
  var f = parseInt(s, undefined);
  if (!Number.isNaN(f)) {
    return fromFloat$5(f);
  }
  
}

function fromStringExn$5(s) {
  var f = parseInt(s, undefined);
  if (Number.isNaN(f)) {
    return PervasivesU.invalid_arg("the string is not an integer: " + s);
  } else {
    return fromFloatExn$5(f);
  }
}

function toStringWithRadixExn$5(i, radix) {
  return i.toString(radix);
}

function toExponential$5(i) {
  return i.toExponential();
}

function toExponentialWithPrecisionExn$5(i, digits) {
  return i.toExponential(digits);
}

function toPrecision$5(i) {
  return i.toPrecision();
}

function toPrecisionWithPrecisionExn$5(i, digits) {
  return i.toPrecision(digits);
}

function fromFloatUncheckInteger$5(f) {
  if (f >= 0.0 && f <= 4294967295.0) {
    return toUint32(f);
  }
  
}

function fromFloatUncheckIntegerExn$5(f) {
  if (f >= 0.0 && f <= 4294967295.0) {
    return toUint32(f);
  } else {
    return ResNumber__Utils.raiseOverflow(f, IntModule);
  }
}

function fromFloatUncheckIntegerClamped$5(f) {
  if (f < 0.0) {
    return 0.0;
  } else if (f > 4294967295.0) {
    return 4294967295.0;
  } else {
    return toUint32(f);
  }
}

function fromStringWithRadix$5(s, radix) {
  var f = parseInt(s, radix);
  if (!Number.isNaN(f)) {
    return fromFloatUncheckInteger$5(f);
  }
  
}

function fromStringWithRadixExn$5(s, radix) {
  var f = parseInt(s, radix);
  if (Number.isNaN(f)) {
    if (radix >= 2 && radix <= 36) {
      return PervasivesU.invalid_arg("the string is not an integer: " + s);
    } else {
      return PervasivesU.invalid_arg("the radix is less than 2 or greater than 36: " + radix.toString());
    }
  } else {
    return fromFloatUncheckIntegerExn$5(f);
  }
}

function compareExn$5(a, b) {
  if (a < b) {
    return -1;
  } else if (a > b) {
    return 1;
  } else {
    return 0;
  }
}

function compare$5(a, b) {
  return compareExn$5(a, b);
}

function eq$5(a, b) {
  return a === b;
}

function ne$5(a, b) {
  return a !== b;
}

function lt$5(a, b) {
  return a < b;
}

function le$5(a, b) {
  return a <= b;
}

function gt$5(a, b) {
  return a > b;
}

function ge$5(a, b) {
  return a >= b;
}

function min$5(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}

function minMany$5(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.min, [arr]);
  }
  
}

function minManyExn$5(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.min, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function minManyUnsafe$5(arr) {
  return toUint32(Caml_splice_call.spliceApply(Math.min, [arr]));
}

function max$5(a, b) {
  if (a > b) {
    return a;
  } else {
    return b;
  }
}

function maxMany$5(arr) {
  var len = arr.length;
  if (len > 0) {
    return len === 1 ? arr[0] : Caml_splice_call.spliceApply(Math.max, [arr]);
  }
  
}

function maxManyExn$5(arr) {
  var len = arr.length;
  if (len > 0) {
    if (len === 1) {
      return arr[0];
    } else {
      return Caml_splice_call.spliceApply(Math.max, [arr]);
    }
  } else {
    return ResNumber__Utils.raiseEmptyArray();
  }
}

function maxManyUnsafe$5(arr) {
  return toUint32(Caml_splice_call.spliceApply(Math.max, [arr]));
}

function add$5(a, b) {
  return fromFloatUncheckInteger$5(a + b);
}

function addExn$5(a, b) {
  return fromFloatUncheckIntegerExn$5(a + b);
}

function addClamped$5(a, b) {
  return fromFloatUncheckIntegerClamped$5(a + b);
}

function addUnsafe$5(a, b) {
  return toUint32(a + b);
}

function sub$5(a, b) {
  return fromFloatUncheckInteger$5(a - b);
}

function subExn$5(a, b) {
  return fromFloatUncheckIntegerExn$5(a - b);
}

function subClamped$5(a, b) {
  return fromFloatUncheckIntegerClamped$5(a - b);
}

function subUnsafe$5(a, b) {
  return toUint32(a - b);
}

function mul$5(a, b) {
  return fromFloatUncheckInteger$5(a * b);
}

function mulExn$5(a, b) {
  return fromFloatUncheckIntegerExn$5(a * b);
}

function mulClamped$5(a, b) {
  return fromFloatUncheckIntegerClamped$5(a * b);
}

function mulUnsafe$5(a, b) {
  return toUint32(a * b);
}

function divUnsafe$5(a, b) {
  return toUint32(a / b);
}

function div$5(a, b) {
  if (b !== 0.0) {
    return divUnsafe$5(a, b);
  }
  
}

function divExn$5(a, b) {
  if (b !== 0.0) {
    return divUnsafe$5(a, b);
  }
  throw {
        RE_EXN_ID: "Division_by_zero",
        Error: new Error()
      };
}

function remUnsafe$5(a, b) {
  return toUint32(a % b);
}

function rem$5(a, b) {
  if (b !== 0.0) {
    return remUnsafe$5(a, b);
  }
  
}

function remExn$5(a, b) {
  if (b !== 0.0) {
    return remUnsafe$5(a, b);
  }
  throw {
        RE_EXN_ID: "Division_by_zero",
        Error: new Error()
      };
}

var include$5 = ResNumber__Operation.MakeNumberSum({
      add: add$5,
      addExn: addExn$5,
      addClamped: addClamped$5,
      addUnsafe: addUnsafe$5
    });

function inc$5(n) {
  return add$5(n, 1.0);
}

function incExn$5(n) {
  return addExn$5(n, 1.0);
}

function incUnsafe$5(n) {
  return addUnsafe$5(n, 1.0);
}

function dec$5(n) {
  return sub$5(n, 1.0);
}

function decExn$5(n) {
  return subExn$5(n, 1.0);
}

function decUnsafe$5(n) {
  return subUnsafe$5(n, 1.0);
}

function lnot$5(i) {
  return toUint32(PervasivesU.lnot(i));
}

function land$5(a, b) {
  return toUint32(a & b);
}

function lor$5(a, b) {
  return toUint32(a | b);
}

function lxor$5(a, b) {
  return toUint32(a ^ b);
}

function lsl$5(i, n) {
  return toUint32((i << n));
}

function lsr$5(i, n) {
  return (i >>> n);
}

function modBits$5(n) {
  if (n < 0 || n >= 32) {
    return toUint32(n) % 32;
  } else {
    return n;
  }
}

function rsl$5(i, n) {
  var m = modBits$5(n);
  if (m !== 0) {
    return toUint32((i << m) | (i >>> (32 - m | 0)) | 0);
  } else {
    return i;
  }
}

function rsr$5(i, n) {
  var m = modBits$5(n);
  if (m !== 0) {
    return toUint32((i >>> m) | 0 | (i << (32 - m | 0)));
  } else {
    return i;
  }
}

function clz$5(i) {
  return Math.clz32(i);
}

function imul$5(a, b) {
  return toUint32(Math.imul(a, b));
}

function pow_$5(base, exp) {
  return Math.pow(base, exp);
}

function pow$5(base, exp) {
  return fromFloat$5(pow_$5(base, exp));
}

function powExn$5(base, exp) {
  return fromFloatExn$5(pow_$5(base, exp));
}

function powUnsafe$5(base, exp) {
  return toUint32(pow_$5(base, exp));
}

function random$5(min, max) {
  return fromFloatClamped$5(Math.floor(Math.random() * (max - min) + min));
}

var Uint32_sum = include$5.sum;

var Uint32_sumExn = include$5.sumExn;

var Uint32_sumUnsafe = include$5.sumUnsafe;

var Uint32 = {
  isSigned: false,
  isUnsigned: true,
  bits: 32,
  fromInt: fromInt$5,
  fromIntExn: fromIntExn$5,
  fromIntClamped: fromIntClamped$5,
  fromIntUnsafe: fromIntUnsafe$5,
  toInt: toInt$5,
  toIntExn: toIntExn$5,
  toIntClamped: toIntClamped$5,
  toIntUnsafe: toIntUnsafe$5,
  fromFloat: fromFloat$5,
  fromFloatExn: fromFloatExn$5,
  fromFloatClamped: fromFloatClamped$5,
  fromFloatUnsafe: fromFloatUnsafe$5,
  toFloat: toFloat$5,
  fromString: fromString$5,
  fromStringExn: fromStringExn$5,
  toString: toString$5,
  toStringWithRadixExn: toStringWithRadixExn$5,
  toExponential: toExponential$5,
  toExponentialWithPrecisionExn: toExponentialWithPrecisionExn$5,
  toPrecision: toPrecision$5,
  toPrecisionWithPrecisionExn: toPrecisionWithPrecisionExn$5,
  fromStringWithRadix: fromStringWithRadix$5,
  fromStringWithRadixExn: fromStringWithRadixExn$5,
  zero: 0.0,
  one: 1.0,
  minValue: 0.0,
  maxValue: 4294967295.0,
  compare: compare$5,
  compareExn: compareExn$5,
  eq: eq$5,
  ne: ne$5,
  lt: lt$5,
  le: le$5,
  gt: gt$5,
  ge: ge$5,
  min: min$5,
  minMany: minMany$5,
  minManyExn: minManyExn$5,
  minManyUnsafe: minManyUnsafe$5,
  max: max$5,
  maxMany: maxMany$5,
  maxManyExn: maxManyExn$5,
  maxManyUnsafe: maxManyUnsafe$5,
  add: add$5,
  addExn: addExn$5,
  addClamped: addClamped$5,
  addUnsafe: addUnsafe$5,
  sub: sub$5,
  subExn: subExn$5,
  subClamped: subClamped$5,
  subUnsafe: subUnsafe$5,
  mul: mul$5,
  mulExn: mulExn$5,
  mulClamped: mulClamped$5,
  mulUnsafe: mulUnsafe$5,
  div: div$5,
  divExn: divExn$5,
  divUnsafe: divUnsafe$5,
  rem: rem$5,
  remExn: remExn$5,
  remUnsafe: remUnsafe$5,
  sum: Uint32_sum,
  sumExn: Uint32_sumExn,
  sumUnsafe: Uint32_sumUnsafe,
  inc: inc$5,
  incExn: incExn$5,
  incUnsafe: incUnsafe$5,
  dec: dec$5,
  decExn: decExn$5,
  decUnsafe: decUnsafe$5,
  lnot: lnot$5,
  land: land$5,
  lor: lor$5,
  lxor: lxor$5,
  lsl: lsl$5,
  lsr: lsr$5,
  asr: lsr$5,
  rsl: rsl$5,
  rsr: rsr$5,
  clz: clz$5,
  imul: imul$5,
  pow: pow$5,
  powExn: powExn$5,
  powUnsafe: powUnsafe$5,
  random: random$5
};

export {
  MakeIntegerConversion ,
  MakeNumberIncDec ,
  MakeInteger ,
  MakeFixedBitsIntegerConversion ,
  MakeFixedBitsInt ,
  MakeIntegerMath ,
  MakeFixedBitsInteger ,
  MakeSignedInteger ,
  MakeUnsignedInteger ,
  Int8 ,
  Uint8 ,
  Int16 ,
  Uint16 ,
  Int32 ,
  Uint32 ,
}
/*  Not a pure module */
